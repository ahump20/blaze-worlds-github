<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🚀 Blaze Worlds Ultimate - Epic Cosmic Universe Exploration</title>
    <meta name="description" content="Explore infinite cosmic realms with stunning nebulae, alien structures, and immersive space phenomena">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🚀</text></svg>">
    <style>
        :root {
            --cosmic-purple: #6B46C1;
            --nebula-blue: #3B82F6;
            --stellar-cyan: #06B6D4;
            --deep-space: #0F0F23;
            --starlight: #F8FAFC;
            --void-black: #1A1A2E;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            background: radial-gradient(ellipse at center, var(--deep-space) 0%, var(--void-black) 70%, #000000 100%);
            overflow: hidden;
            color: var(--stellar-cyan);
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
            transition: filter 0.3s ease;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-panel {
            background: rgba(15, 15, 35, 0.9);
            border: 2px solid var(--cosmic-purple);
            border-radius: 12px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(107, 70, 193, 0.4);
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 20px;
            color: var(--nebula-blue);
            font-size: 14px;
            min-width: 280px;
        }

        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            padding: 15px;
            color: var(--nebula-blue);
        }

        #inventory {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 15px;
            color: var(--grizzly-teal);
            display: flex;
            gap: 10px;
        }

        .inventory-slot {
            width: 50px;
            height: 50px;
            border: 2px solid var(--grizzly-teal);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: rgba(0, 178, 169, 0.1);
            transition: all 0.2s ease;
        }

        .inventory-slot:hover {
            background: rgba(0, 178, 169, 0.3);
            transform: scale(1.1);
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            border: 3px solid var(--texas-orange);
            border-radius: 50%;
            opacity: 0.8;
            animation: pulse 2s infinite;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 20px;
            color: var(--nebula-blue);
            font-size: 12px;
            max-width: 350px;
            line-height: 1.4;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, var(--tennessee-deep), var(--texas-orange));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1.5s ease-out;
        }

        #loadingTitle {
            font-size: 4em;
            color: var(--pearl-white);
            text-shadow: 0 0 30px var(--texas-orange);
            margin-bottom: 30px;
            animation: titleGlow 3s infinite;
            font-weight: bold;
        }

        #loadingSubtitle {
            font-size: 1.5em;
            color: var(--nebula-blue);
            margin-bottom: 40px;
            text-align: center;
        }

        #loadingBar {
            width: 400px;
            height: 12px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            overflow: hidden;
            border: 2px solid var(--texas-orange);
        }

        #loadingProgress {
            height: 100%;
            background: linear-gradient(90deg, var(--texas-orange), var(--grizzly-teal), var(--cardinal-blue));
            width: 0%;
            transition: width 0.4s ease;
            border-radius: 4px;
        }

        #performance {
            position: absolute;
            top: 200px;
            left: 20px;
            padding: 15px;
            color: var(--grizzly-teal);
            font-size: 12px;
            opacity: 0.8;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        }

        @keyframes titleGlow {
            0%, 100% { text-shadow: 0 0 30px var(--texas-orange); }
            50% { text-shadow: 0 0 50px var(--texas-orange), 0 0 100px var(--grizzly-teal); }
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }

        .stat-value {
            font-weight: bold;
            color: var(--texas-orange);
        }

        #particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--grizzly-teal);
            border-radius: 50%;
            animation: particleFloat 20s infinite linear;
        }

        @keyframes particleFloat {
            0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-10vh) rotate(360deg); opacity: 0; }
        }

        #worldSelector {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px;
            z-index: 200;
            text-align: center;
            pointer-events: all;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #worldSelector.active {
            opacity: 1;
        }

        .world-option {
            margin: 10px;
            padding: 15px 25px;
            background: var(--texas-orange);
            color: var(--pearl-white);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .world-option:hover {
            background: var(--grizzly-teal);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Loading Screen -->
        <div id="loadingScreen" style="
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0F0F23 0%, #1A1A2E 50%, #000000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            color: #06B6D4;
            font-family: 'JetBrains Mono', monospace;
        ">
            <div style="text-align: center;">
                <div style="font-size: 4rem; margin-bottom: 20px;">🚀</div>
                <h1 style="font-size: 2rem; margin: 20px 0; color: #6B46C1;">Blaze Worlds Ultimate</h1>
                <p style="font-size: 1.2rem; margin: 10px 0; color: #3B82F6;">Initializing Cosmic Universe...</p>
                <div id="loadingProgress" style="
                    width: 300px;
                    height: 4px;
                    background: rgba(255,255,255,0.1);
                    border-radius: 2px;
                    margin: 20px auto;
                    overflow: hidden;
                ">
                    <div id="progressBar" style="
                        width: 0%;
                        height: 100%;
                        background: linear-gradient(90deg, #6B46C1, #06B6D4);
                        border-radius: 2px;
                        transition: width 0.5s ease;
                    "></div>
                </div>
                <p id="loadingText" style="font-size: 1rem; color: #F8FAFC; opacity: 0.8;">Loading Three.js...</p>
            </div>
        </div>
        
        <div id="particles"></div>
        
        <div id="ui">
            <div id="hud" class="ui-panel">
                <div style="font-size: 16px; font-weight: bold; margin-bottom: 10px;">
                    🌌 BLAZE WORLDS ULTIMATE
                </div>
                <div class="stat-row">
                    <span>Position:</span>
                    <span class="stat-value" id="coordinates">0, 0, 0</span>
                </div>
                <div class="stat-row">
                    <span>Biome:</span>
                    <span class="stat-value" id="biome">Frontier Plains</span>
                </div>
                <div class="stat-row">
                    <span>Altitude:</span>
                    <span class="stat-value" id="altitude">64m</span>
                </div>
                <div class="stat-row">
                    <span>Velocity:</span>
                    <span class="stat-value" id="speed">0 km/h</span>
                </div>
                <div class="stat-row">
                    <span>Fuel:</span>
                    <span class="stat-value" id="fuel">∞</span>
                </div>
                <div class="stat-row">
                    <span>World Seed:</span>
                    <span class="stat-value" id="worldSeed">0000</span>
                </div>
            </div>

            <div id="minimap" class="ui-panel">
                <div style="font-weight: bold; margin-bottom: 10px;">📍 NAVIGATION</div>
                <canvas id="minimapCanvas" width="170" height="120" style="border-radius: 6px;"></canvas>
            </div>

            <div id="performance" class="ui-panel">
                <div style="font-weight: bold; margin-bottom: 8px;">⚡ PERFORMANCE</div>
                <div class="stat-row">
                    <span>FPS:</span>
                    <span class="stat-value" id="fps">60</span>
                </div>
                <div class="stat-row">
                    <span>Chunks:</span>
                    <span class="stat-value" id="chunkCount">0</span>
                </div>
                <div class="stat-row">
                    <span>Triangles:</span>
                    <span class="stat-value" id="triangles">0</span>
                </div>
            </div>

            <div id="inventory" class="ui-panel">
                <div class="inventory-slot">🔧</div>
                <div class="inventory-slot">🌱</div>
                <div class="inventory-slot">💎</div>
                <div class="inventory-slot">🔋</div>
                <div class="inventory-slot">🛡️</div>
            </div>

            <div id="crosshair"></div>

            <div id="instructions" class="ui-panel">
                <h3 style="color: var(--cosmic-purple); margin-bottom: 15px;">🚀 COSMIC NAVIGATION CONTROLS</h3>
                <div><strong>WASD</strong> - Navigate cosmic space</div>
                <div><strong>Space</strong> - Jetpack boost upward</div>
                <div><strong>Shift</strong> - Jetpack thrust downward</div>
                <div><strong>Mouse</strong> - Look around universe</div>
                <div><strong>Scroll</strong> - Propulsion speed control</div>
                <div><strong>R</strong> - Generate new galaxy</div>
                <div><strong>F</strong> - Toggle cosmic wireframe</div>
                <div><strong>G</strong> - Galaxy sector selector</div>
                <div><strong>V</strong> - Change view mode</div>
                <div><strong>H</strong> - Deploy/Board spacecraft</div>
                <br>
                <div style="color: var(--stellar-cyan); font-style: italic;">
                    ✨ Explore infinite cosmic realms with championship-level procedural universe generation and stellar phenomena!
                </div>
            </div>
        </div>

        <div id="worldSelector" class="ui-panel">
            <h2 style="color: var(--texas-orange); margin-bottom: 20px;">🌍 WORLD GENERATOR</h2>
            <button class="world-option" onclick="game.generateSpecialWorld('desert')">🏜️ Texas Desert</button>
            <button class="world-option" onclick="game.generateSpecialWorld('forest')">🌲 Piney Woods</button>
            <button class="world-option" onclick="game.generateSpecialWorld('canyon')">🏔️ Palo Duro Canyon</button>
            <button class="world-option" onclick="game.generateSpecialWorld('coast')">🌊 Gulf Coast</button>
            <button class="world-option" onclick="game.generateSpecialWorld('random')">🎲 Random Frontier</button>
            <button class="world-option" onclick="game.hideWorldSelector()" style="background: var(--graphite);">❌ Cancel</button>
        </div>

        <div id="loadingScreen">
            <div id="loadingTitle">BLAZE WORLDS</div>
            <div id="loadingSubtitle">Generating Infinite Championship Frontiers...</div>
            <div id="loadingBar">
                <div id="loadingProgress"></div>
            </div>
            <div style="margin-top: 20px; color: var(--cardinal-blue);">
                Powered by Texas Innovation • Built for Champions
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script>
        // Add error checking for Three.js
        if (typeof THREE === 'undefined') {
            console.error('Three.js failed to load! Trying alternative CDN...');
            document.write('<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"><\/script>');
        } else {
            console.log('Three.js loaded successfully:', THREE.REVISION);
        }
    </script>
    <script>
        class BlazeWorldsUltimate {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.clock = new THREE.Clock();
                
                this.controls = {
                    moveForward: false,
                    moveBackward: false,
                    moveLeft: false,
                    moveRight: false,
                    moveUp: false,
                    moveDown: false,
                    sprint: false
                };
                
                this.velocity = new THREE.Vector3();
                this.direction = new THREE.Vector3();
                this.playerPosition = new THREE.Vector3(0, 100, 0);
                this.mouseX = 0;
                this.mouseY = 0;
                this.speed = 75;
                this.maxSpeed = 300;
                this.wireframe = false;
                this.viewMode = 0; // 0: first person, 1: third person, 2: cinematic
                
                this.chunks = new Map();
                this.chunkSize = 256;
                this.renderDistance = 6;
                this.seed = Math.floor(Math.random() * 10000);
                this.worldType = 'cosmic'; // Force cosmic space terrain
                
                // Performance tracking
                this.fps = 60;
                this.frameCount = 0;
                this.lastFPSUpdate = 0;
                
                // Blaze Intelligence cosmic universe color palette
                this.colors = {
                    primary: 0x6B46C1,    // Cosmic Purple
                    secondary: 0x3B82F6,  // Nebula Blue
                    accent: 0x06B6D4,     // Stellar Cyan
                    dark: 0x0F0F23,       // Deep Space
                    light: 0xF8FAFC,      // Starlight White
                    graphite: 0x1A1A2E    // Void Black
                };

                // Weather and atmospheric effects
                this.weather = {
                    rain: false,
                    intensity: 0,
                    particles: []
                };

                // Character and spacecraft mechanics
                this.playerCharacter = null;
                this.spacecraft = null;
                this.isMounted = false;
                this.isWalking = false;
                this.walkAnimation = 0;
                this.walkCycle = 0;
                this.lastFootstepTime = 0;
                this.spacecraftPosition = new THREE.Vector3();

                // Audio and storytelling system
                this.audioContext = null;
                this.audioSources = {};
                this.ambientSounds = [];
                this.narrativeElements = [];
                this.discoveredLandmarks = new Set();
                this.storyProgress = 0;
                this.audioEnabled = false;

                this.init();
            }

            init() {
                this.setupRenderer();
                this.setupScene();
                this.setupCamera();
                this.setupLighting();
                this.setupEventListeners();
                this.setupParticleSystem();
                this.setupAudioSystem();
                this.setupNarrativeElements();
                this.createCosmicStarField();
                this.createAIDrivenUniverse();
                this.createPulsatingPhenomena();
                this.createBlackHoles();
                this.createWormholePortals();
                this.createAsteroidBelts();
                this.generateInitialTerrain();
                this.addNavigationStatusToUI();
                this.addSpacecraftUIElements();
                this.animate();
                this.hideLoadingScreen();
                this.createFloatingParticles();
            }

            setupRenderer() {
                const canvas = document.getElementById('gameCanvas');
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.fog = true;
                this.renderer.setClearColor(0x0A0A0F, 1); // Deep space color
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x0F0F23, 1000, 4000); // Deep space nebula fog
                
                // Championship-level dynamic skybox
                const skyGeometry = new THREE.SphereGeometry(2500, 64, 64);
                const skyMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        topColor: { value: new THREE.Color(0x0077ff) },
                        bottomColor: { value: new THREE.Color(0xffffff) },
                        offset: { value: 33 },
                        exponent: { value: 0.6 }
                    },
                    vertexShader: `
                        varying vec3 vWorldPosition;
                        void main() {
                            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                            vWorldPosition = worldPosition.xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 topColor;
                        uniform vec3 bottomColor;
                        uniform float offset;
                        uniform float exponent;
                        uniform float time;
                        varying vec3 vWorldPosition;
                        void main() {
                            float h = normalize(vWorldPosition + offset).y;
                            float t = max(pow(max(h, 0.0), exponent), 0.0);
                            vec3 color = mix(bottomColor, topColor, t);
                            
                            // Add dynamic color shifts
                            color.r += sin(time * 0.001) * 0.1;
                            color.g += cos(time * 0.0015) * 0.1;
                            color.b += sin(time * 0.002) * 0.1;
                            
                            gl_FragColor = vec4(color, 1.0);
                        }
                    `,
                    side: THREE.BackSide
                });
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                this.sky = sky;
                this.scene.add(sky);
            }

            setupCamera() {
                this.camera = new THREE.PerspectiveCamera(
                    80, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    4000
                );
                this.camera.position.copy(this.playerPosition);
                
                // Third person camera setup
                this.cameraOffset = new THREE.Vector3(0, 20, 30);
                this.lookAtOffset = new THREE.Vector3(0, 0, 0);
                
                // Create player character and horse
                this.createPlayerCharacter();
                this.createSpacecraft();
                this.createCosmicRadiationField();
            }

            setupLighting() {
                // Texas-inspired dynamic lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);

                // Primary sun light
                const sunLight = new THREE.DirectionalLight(this.colors.primary, 1.2);
                sunLight.position.set(200, 300, 100);
                sunLight.castShadow = true;
                sunLight.shadow.mapSize.width = 4096;
                sunLight.shadow.mapSize.height = 4096;
                sunLight.shadow.camera.near = 0.5;
                sunLight.shadow.camera.far = 1000;
                sunLight.shadow.camera.left = -500;
                sunLight.shadow.camera.right = 500;
                sunLight.shadow.camera.top = 500;
                sunLight.shadow.camera.bottom = -500;
                this.scene.add(sunLight);
                this.sunLight = sunLight;

                // Atmospheric point lights
                this.atmosphericLights = [];
                for (let i = 0; i < 8; i++) {
                    const colors = [this.colors.accent, this.colors.secondary, this.colors.primary];
                    const light = new THREE.PointLight(
                        colors[i % 3],
                        0.3,
                        300
                    );
                    light.position.set(
                        (Math.random() - 0.5) * 2000,
                        50 + Math.random() * 150,
                        (Math.random() - 0.5) * 2000
                    );
                    this.scene.add(light);
                    this.atmosphericLights.push(light);
                }
            }

            setupParticleSystem() {
                // Create cosmic background radiation particle system
                const particleGeometry = new THREE.BufferGeometry();
                const particleCount = 2500; // Increased for dense cosmic radiation field
                const positions = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    // Distribute cosmic radiation particles in vast 3D sphere
                    const radius = 1500 + Math.random() * 1000; // 1500-2500 units radius
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = radius * Math.cos(phi) + (Math.random() - 0.5) * 400;
                    positions[i3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
                    
                    // Cosmic microwave background particles move very slowly in all directions
                    velocities[i3] = (Math.random() - 0.5) * 0.8;
                    velocities[i3 + 1] = (Math.random() - 0.5) * 0.8;
                    velocities[i3 + 2] = (Math.random() - 0.5) * 0.8;
                    
                    // Color cosmic radiation particles with subtle cosmic spectrum
                    const particleType = Math.random();
                    if (particleType < 0.6) {
                        // Cosmic microwave background - subtle blue/white
                        colors[i3] = 0.7 + Math.random() * 0.3;     // R
                        colors[i3 + 1] = 0.8 + Math.random() * 0.2; // G  
                        colors[i3 + 2] = 0.9 + Math.random() * 0.1; // B (subtle blue tint)
                    } else if (particleType < 0.85) {
                        // High energy cosmic rays - purple/magenta
                        colors[i3] = 0.6 + Math.random() * 0.4;     // R
                        colors[i3 + 1] = 0.2 + Math.random() * 0.3; // G
                        colors[i3 + 2] = 0.8 + Math.random() * 0.2; // B (purple)
                    } else {
                        // Rare gamma ray bursts - bright cyan
                        colors[i3] = 0.1 + Math.random() * 0.3;     // R
                        colors[i3 + 1] = 0.8 + Math.random() * 0.2; // G
                        colors[i3 + 2] = 0.9 + Math.random() * 0.1; // B (cyan)
                    }
                    
                    // Vary particle sizes for realistic cosmic radiation
                    sizes[i] = 0.8 + Math.random() * 1.5;
                }
                
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const particleMaterial = new THREE.PointsMaterial({
                    size: 1.5,
                    transparent: true,
                    opacity: 0.3,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending, // Additive blending for glowing effect
                    sizeAttenuation: true
                });
                
                this.cosmicRadiationParticles = new THREE.Points(particleGeometry, particleMaterial);
                this.cosmicRadiationVelocities = velocities;
                this.scene.add(this.cosmicRadiationParticles);
                
                console.log('⚡ Created cosmic background radiation field with 2500 particles');
            }

            setupAudioSystem() {
                // Initialize Web Audio API for immersive cosmic radio telescope soundscape
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.createCosmicAudio();
                } catch (error) {
                    console.log('🎵 Audio context not available - visual experience only');
                }
                
                // Enable audio on first user interaction
                document.addEventListener('click', () => {
                    if (this.audioContext && !this.audioEnabled) {
                        this.audioContext.resume();
                        this.audioEnabled = true;
                        this.startCosmicSounds();
                        console.log('🔊 Cosmic radio telescope system activated');
                    }
                });
            }

            createCosmicAudio() {
                if (!this.audioContext) return;

                // Create deep space radio telescope signals
                this.createRadioTelescopeSignals();
                
                // Create cosmic background radiation hum
                this.createCosmicBackgroundHum();
                
                // Create spacecraft thruster and movement sounds
                this.createSpacecraftSounds();
                
                // Create alien transmission narration system
                this.createCosmicNarrationSystem();
            }

            createRadioTelescopeSignals() {
                if (!this.audioContext) return;
                
                const signalGain = this.audioContext.createGain();
                signalGain.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                signalGain.connect(this.audioContext.destination);
                
                // Generate deep space radio telescope signals with pulsar-like patterns
                const signalBuffer = this.audioContext.createBuffer(2, this.audioContext.sampleRate * 8, this.audioContext.sampleRate);
                const leftChannel = signalBuffer.getChannelData(0);
                const rightChannel = signalBuffer.getChannelData(1);
                
                for (let i = 0; i < leftChannel.length; i++) {
                    const time = i / this.audioContext.sampleRate;
                    
                    // Create pulsar rhythmic patterns (like PSR B1919+21)
                    const pulsarFreq = 0.3; // 0.3 Hz pulsar
                    const pulse = Math.sin(2 * Math.PI * pulsarFreq * time) > 0.7 ? 1 : 0;
                    
                    // Add cosmic background radiation static
                    const cosmicNoise = (Math.random() * 2 - 1) * 0.08;
                    
                    // Add mysterious low-frequency hum from distant quasars
                    const quasarHum = Math.sin(2 * Math.PI * 40 * time) * 0.1;
                    
                    // Combine signals with spatial positioning
                    leftChannel[i] = (pulse * 0.3 + cosmicNoise + quasarHum) * 0.7;
                    rightChannel[i] = (pulse * 0.2 + cosmicNoise * 0.8 + quasarHum * 1.2) * 0.7;
                }
                
                const signalSource = this.audioContext.createBufferSource();
                signalSource.buffer = signalBuffer;
                signalSource.loop = true;
                
                // Apply band-pass filter for authentic radio telescope sound
                const radioFilter = this.audioContext.createBiquadFilter();
                radioFilter.type = 'bandpass';
                radioFilter.frequency.setValueAtTime(1200, this.audioContext.currentTime);
                radioFilter.Q.setValueAtTime(2, this.audioContext.currentTime);
                
                signalSource.connect(radioFilter);
                radioFilter.connect(signalGain);
                
                this.audioSources.radioTelescope = { source: signalSource, gain: signalGain };
            }

            createCosmicBackgroundHum() {
                if (!this.audioContext) return;
                
                const cmbGain = this.audioContext.createGain();
                cmbGain.gain.setValueAtTime(0.08, this.audioContext.currentTime);
                cmbGain.connect(this.audioContext.destination);
                
                // Generate cosmic microwave background radiation (2.7K thermal noise)
                const cmbBuffer = this.audioContext.createBuffer(2, this.audioContext.sampleRate * 12, this.audioContext.sampleRate);
                const leftCMB = cmbBuffer.getChannelData(0);
                const rightCMB = cmbBuffer.getChannelData(1);
                
                for (let i = 0; i < leftCMB.length; i++) {
                    const time = i / this.audioContext.sampleRate;
                    
                    // Base cosmic microwave background - very low frequency rumble
                    const cmbFreq = 15 + Math.sin(time * 0.1) * 5; // 10-20 Hz variation
                    const cmbSignal = Math.sin(2 * Math.PI * cmbFreq * time) * 0.3;
                    
                    // Add thermal noise characteristic of 2.7K temperature
                    const thermalNoise = (Math.random() * 2 - 1) * 0.05;
                    
                    // Occasional mysterious deep space signals
                    const mysteriousSignal = Math.sin(2 * Math.PI * 0.05 * time) * 
                                            Math.sin(2 * Math.PI * 180 * time) * 0.1;
                    
                    leftCMB[i] = cmbSignal + thermalNoise + mysteriousSignal;
                    rightCMB[i] = cmbSignal * 0.9 + thermalNoise * 1.1 + mysteriousSignal * 0.8;
                }
                
                const cmbSource = this.audioContext.createBufferSource();
                cmbSource.buffer = cmbBuffer;
                cmbSource.loop = true;
                
                // Apply very low-pass filter to simulate deep space isolation
                const deepSpaceFilter = this.audioContext.createBiquadFilter();
                deepSpaceFilter.type = 'lowpass';
                deepSpaceFilter.frequency.setValueAtTime(150, this.audioContext.currentTime);
                deepSpaceFilter.Q.setValueAtTime(0.8, this.audioContext.currentTime);
                
                cmbSource.connect(deepSpaceFilter);
                deepSpaceFilter.connect(cmbGain);
                
                this.audioSources.cosmicBackground = { source: cmbSource, gain: cmbGain };
            }

            createCoyoteHowl() {
                if (!this.audioContext) return;
                
                const coyoteGain = this.audioContext.createGain();
                coyoteGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                coyoteGain.connect(this.audioContext.destination);
                
                // Generate coyote howl using oscillators
                const oscillator1 = this.audioContext.createOscillator();
                const oscillator2 = this.audioContext.createOscillator();
                
                oscillator1.type = 'sawtooth';
                oscillator2.type = 'sine';
                
                oscillator1.connect(coyoteGain);
                oscillator2.connect(coyoteGain);
                
                this.audioSources.coyote = { oscillator1, oscillator2, gain: coyoteGain };
            }

            createInsectAmbience() {
                if (!this.audioContext) return;
                
                const insectGain = this.audioContext.createGain();
                insectGain.gain.setValueAtTime(0.05, this.audioContext.currentTime);
                insectGain.connect(this.audioContext.destination);
                
                // Generate cricket chirping using rapid oscillation
                const cricketOsc = this.audioContext.createOscillator();
                cricketOsc.type = 'square';
                cricketOsc.frequency.setValueAtTime(2000, this.audioContext.currentTime);
                
                // Create tremolo effect for cricket chirping
                const tremolo = this.audioContext.createOscillator();
                tremolo.type = 'sine';
                tremolo.frequency.setValueAtTime(8, this.audioContext.currentTime);
                
                const tremoloGain = this.audioContext.createGain();
                tremoloGain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                
                tremolo.connect(tremoloGain);
                tremoloGain.connect(cricketOsc.frequency);
                cricketOsc.connect(insectGain);
                
                this.audioSources.insects = { cricket: cricketOsc, tremolo, gain: insectGain };
            }

            createCattleSounds() {
                if (!this.audioContext) return;
                
                const cattleGain = this.audioContext.createGain();
                cattleGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                cattleGain.connect(this.audioContext.destination);
                
                this.audioSources.cattle = { gain: cattleGain };
            }

            createMovementSounds() {
                if (!this.audioContext) return;
                
                // Footstep sound generator
                const footstepGain = this.audioContext.createGain();
                footstepGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                footstepGain.connect(this.audioContext.destination);
                
                // Horse hoofbeat sound generator
                const hoofbeatGain = this.audioContext.createGain();
                hoofbeatGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                hoofbeatGain.connect(this.audioContext.destination);
                
                this.audioSources.movement = { 
                    footsteps: footstepGain, 
                    hoofbeats: hoofbeatGain 
                };
            }

            createNarrationSystem() {
                // Environmental storytelling phrases for Texas Hill Country
                this.narrativeElements = [
                    {
                        trigger: 'landmark_discovery',
                        texts: [
                            "Ancient alien technology hums with residual energy...",
                            "This quantum beacon has guided countless starships home...",
                            "Twisted wreckage tells tales of interstellar battles...",
                            "A crystalline monolith marks dimensional convergence points...",
                            "Nebula portals shimmer with otherworldly possibilities...",
                            "Abandoned outposts whisper of civilizations long gone...",
                            "Cosmic crystals pulse with stellar radiation...",
                            "Singularity remnants bend spacetime around them...",
                            "Wormhole portal tears through reality itself, bridging distant galaxies..."
                        ]
                    },
                    {
                        trigger: 'weather_change',
                        texts: [
                            "Solar storms cascade across the cosmic void...",
                            "Stellar winds carry echoes of distant galaxies...",
                            "Nebula clouds shift in brilliant purple hues...",
                            "New stars ignite in the infinite darkness..."
                        ]
                    },
                    {
                        trigger: 'spacecraft_call',
                        texts: [
                            "Your trusty vessel approaches through the asteroid field...",
                            "Engine thrusters illuminate the cosmic darkness...",
                            "The spacecraft's hull gleams with starlight..."
                        ]
                    },
                    {
                        trigger: 'exploration',
                        texts: [
                            "Every star system holds the promise of new worlds...",
                            "The universe stretches infinite, mysterious and vast...",
                            "Somewhere among the stars, destiny awaits..."
                        ]
                    }
                ];
            }

            setupNarrativeElements() {
                // Create narrative text display system
                const narrativeContainer = document.createElement('div');
                narrativeContainer.id = 'narrative-display';
                narrativeContainer.style.cssText = `
                    position: fixed;
                    bottom: 120px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: #BF5700;
                    padding: 15px 25px;
                    border-radius: 8px;
                    font-family: 'Georgia', serif;
                    font-style: italic;
                    font-size: 16px;
                    text-align: center;
                    max-width: 600px;
                    opacity: 0;
                    transition: opacity 0.5s ease;
                    z-index: 1000;
                    border: 2px solid #9BCBEB;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
                `;
                document.body.appendChild(narrativeContainer);
                
                this.narrativeDisplay = narrativeContainer;
            }

            startCosmicSounds() {
                if (!this.audioContext || !this.audioEnabled) return;
                
                // Start cosmic ambience immediately
                this.playCosmicAmbience();
                
                // Start radio telescope signals
                if (this.audioSources.radioTelescope) {
                    this.audioSources.radioTelescope.source.start();
                }
                
                // Start cosmic microwave background radiation
                if (this.audioSources.cosmicBackground) {
                    this.audioSources.cosmicBackground.source.start();
                }
                
                // Schedule random alien transmissions and cosmic ambience
                this.scheduleAlienTransmissions();
                this.scheduleCosmicAmbience();
                
                console.log('🎵 Cosmic radio telescope ambience activated');
            }

            scheduleCosmicAmbience() {
                if (!this.audioContext || !this.audioEnabled) return;
                
                // Play cosmic ambience every 8-12 seconds for continuous atmosphere
                const nextAmbienceDelay = 8000 + Math.random() * 4000;
                
                setTimeout(() => {
                    this.playCosmicAmbience();
                    this.scheduleCosmicAmbience(); // Recursive scheduling
                }, nextAmbienceDelay);
            }

            scheduleAlienTransmissions() {
                if (!this.audioEnabled) return;
                
                // Schedule alien signal burst randomly every 45-120 seconds
                const nextTransmission = (Math.random() * 75 + 45) * 1000;
                setTimeout(() => {
                    this.playAlienSignalBurst();
                    this.scheduleAlienTransmissions();
                }, nextTransmission);
                
                // Schedule distant quasar pulses
                const nextQuasar = (Math.random() * 90 + 60) * 1000;
                setTimeout(() => {
                    this.playQuasarPulse();
                }, nextQuasar);
            }

            playCoyoteHowl() {
                if (!this.audioContext || !this.audioEnabled) return;
                
                // Create a haunting coyote howl
                const howlGain = this.audioContext.createGain();
                const osc1 = this.audioContext.createOscillator();
                const osc2 = this.audioContext.createOscillator();
                
                howlGain.connect(this.audioContext.destination);
                osc1.connect(howlGain);
                osc2.connect(howlGain);
                
                osc1.type = 'sawtooth';
                osc2.type = 'sine';
                
                // Frequency sweep for howl effect
                const currentTime = this.audioContext.currentTime;
                osc1.frequency.setValueAtTime(200, currentTime);
                osc1.frequency.linearRampToValueAtTime(400, currentTime + 1.5);
                osc1.frequency.linearRampToValueAtTime(150, currentTime + 3);
                
                osc2.frequency.setValueAtTime(300, currentTime);
                osc2.frequency.linearRampToValueAtTime(500, currentTime + 1.5);
                osc2.frequency.linearRampToValueAtTime(200, currentTime + 3);
                
                // Volume envelope
                howlGain.gain.setValueAtTime(0, currentTime);
                howlGain.gain.linearRampToValueAtTime(0.1, currentTime + 0.5);
                howlGain.gain.linearRampToValueAtTime(0.15, currentTime + 1.5);
                howlGain.gain.linearRampToValueAtTime(0, currentTime + 3);
                
                osc1.start(currentTime);
                osc2.start(currentTime);
                osc1.stop(currentTime + 3);
                osc2.stop(currentTime + 3);
                
                // Trigger narrative text
                this.displayNarrative('exploration');
            }

            playCattleSound() {
                if (!this.audioContext || !this.audioEnabled) return;
                
                // Create distant cattle lowing sound
                const cattleGain = this.audioContext.createGain();
                const osc = this.audioContext.createOscillator();
                
                cattleGain.connect(this.audioContext.destination);
                osc.connect(cattleGain);
                
                osc.type = 'sawtooth';
                const currentTime = this.audioContext.currentTime;
                
                osc.frequency.setValueAtTime(80, currentTime);
                osc.frequency.linearRampToValueAtTime(120, currentTime + 0.8);
                osc.frequency.linearRampToValueAtTime(70, currentTime + 1.5);
                
                cattleGain.gain.setValueAtTime(0, currentTime);
                cattleGain.gain.linearRampToValueAtTime(0.05, currentTime + 0.3);
                cattleGain.gain.linearRampToValueAtTime(0, currentTime + 1.5);
                
                osc.start(currentTime);
                osc.stop(currentTime + 1.5);
            }

            playFootstepSound() {
                if (!this.audioContext || !this.audioEnabled) return;
                
                // Generate procedural footstep sound
                const stepGain = this.audioContext.createGain();
                const noise = this.audioContext.createBufferSource();
                
                // Create noise buffer for dirt/sand footstep
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.1, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.3;
                }
                
                noise.buffer = buffer;
                noise.connect(stepGain);
                stepGain.connect(this.audioContext.destination);
                
                const currentTime = this.audioContext.currentTime;
                stepGain.gain.setValueAtTime(0.2, currentTime);
                stepGain.gain.exponentialRampToValueAtTime(0.001, currentTime + 0.1);
                
                noise.start(currentTime);
                noise.stop(currentTime + 0.1);
            }

            playHoofbeatSound() {
                if (!this.audioContext || !this.audioEnabled) return;
                
                // Generate horse hoofbeat sound
                const hoofGain = this.audioContext.createGain();
                const osc = this.audioContext.createOscillator();
                
                osc.connect(hoofGain);
                hoofGain.connect(this.audioContext.destination);
                
                osc.type = 'square';
                const currentTime = this.audioContext.currentTime;
                
                osc.frequency.setValueAtTime(200, currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, currentTime + 0.1);
                
                hoofGain.gain.setValueAtTime(0.3, currentTime);
                hoofGain.gain.exponentialRampToValueAtTime(0.001, currentTime + 0.15);
                
                osc.start(currentTime);
                osc.stop(currentTime + 0.15);
            }

            displayNarrative(trigger) {
                if (!this.narrativeDisplay) return;
                
                const narrativeSet = this.narrativeElements.find(set => set.trigger === trigger);
                if (!narrativeSet) return;
                
                const randomText = narrativeSet.texts[Math.floor(Math.random() * narrativeSet.texts.length)];
                
                this.narrativeDisplay.textContent = randomText;
                this.narrativeDisplay.style.opacity = '1';
                
                // Fade out after 4 seconds
                setTimeout(() => {
                    this.narrativeDisplay.style.opacity = '0';
                }, 4000);
                
                console.log('📖 Narrative:', randomText);
            }

            playHoofbeatSequence() {
                // Play a sequence of hoofbeats for horse approaching
                const beats = [0, 300, 600, 1000, 1300, 1600, 2000, 2300];
                beats.forEach(delay => {
                    setTimeout(() => this.playHoofbeatSound(), delay);
                });
            }

            playThrusterAudio() {
                if (!this.audioContext || !this.audioEnabled) return;
                
                // Generate quantum thruster activation sound
                const thrusterGain = this.audioContext.createGain();
                const osc = this.audioContext.createOscillator();
                const osc2 = this.audioContext.createOscillator();
                
                osc.connect(thrusterGain);
                osc2.connect(thrusterGain);
                thrusterGain.connect(this.audioContext.destination);
                
                osc.type = 'sawtooth';
                osc2.type = 'sine';
                const currentTime = this.audioContext.currentTime;
                
                // Low frequency thruster hum
                osc.frequency.setValueAtTime(80, currentTime);
                osc.frequency.exponentialRampToValueAtTime(120, currentTime + 2);
                
                // High frequency quantum resonance
                osc2.frequency.setValueAtTime(400, currentTime);
                osc2.frequency.exponentialRampToValueAtTime(600, currentTime + 2);
                
                thrusterGain.gain.setValueAtTime(0.1, currentTime);
                thrusterGain.gain.linearRampToValueAtTime(0.25, currentTime + 0.5);
                thrusterGain.gain.linearRampToValueAtTime(0.15, currentTime + 2);
                
                osc.start(currentTime);
                osc2.start(currentTime);
                osc.stop(currentTime + 2);
                osc2.stop(currentTime + 2);
            }

            playThrusterHum() {
                if (!this.audioContext || !this.audioEnabled) return;
                
                // Generate brief thruster pulse sound
                const humGain = this.audioContext.createGain();
                const osc = this.audioContext.createOscillator();
                
                osc.connect(humGain);
                humGain.connect(this.audioContext.destination);
                
                osc.type = 'triangle';
                const currentTime = this.audioContext.currentTime;
                
                osc.frequency.setValueAtTime(150, currentTime);
                osc.frequency.linearRampToValueAtTime(180, currentTime + 0.2);
                
                humGain.gain.setValueAtTime(0.2, currentTime);
                humGain.gain.exponentialRampToValueAtTime(0.001, currentTime + 0.2);
                
                osc.start(currentTime);
                osc.stop(currentTime + 0.2);
            }

            playThrusterSequence() {
                // Play a sequence of thruster sounds for spacecraft hyperjump approach
                const thrusterBeats = [0, 200, 400, 800, 1200, 1600, 2000];
                thrusterBeats.forEach(delay => {
                    setTimeout(() => this.playThrusterHum(), delay);
                });
                
                // Play the main thruster activation after the sequence
                setTimeout(() => this.playThrusterAudio(), 2200);
            }

            playRadioTelescopeSignal() {
                if (!this.audioContext || !this.audioEnabled) return;
                
                // Generate radio telescope signal - mysterious cosmic transmission
                const radioGain = this.audioContext.createGain();
                const osc1 = this.audioContext.createOscillator();
                const osc2 = this.audioContext.createOscillator();
                const osc3 = this.audioContext.createOscillator();
                
                osc1.connect(radioGain);
                osc2.connect(radioGain);
                osc3.connect(radioGain);
                radioGain.connect(this.audioContext.destination);
                
                const currentTime = this.audioContext.currentTime;
                
                // Deep space static base
                osc1.type = 'sawtooth';
                osc1.frequency.setValueAtTime(55, currentTime);
                osc1.frequency.linearRampToValueAtTime(45, currentTime + 3);
                
                // Pulsar beacon signal
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(1400, currentTime);
                osc2.frequency.exponentialRampToValueAtTime(1200, currentTime + 0.1);
                
                // Alien harmonic resonance
                osc3.type = 'triangle';
                osc3.frequency.setValueAtTime(280, currentTime);
                osc3.frequency.linearRampToValueAtTime(320, currentTime + 2);
                
                radioGain.gain.setValueAtTime(0.05, currentTime);
                radioGain.gain.linearRampToValueAtTime(0.15, currentTime + 0.5);
                radioGain.gain.linearRampToValueAtTime(0.08, currentTime + 2);
                radioGain.gain.exponentialRampToValueAtTime(0.001, currentTime + 3);
                
                osc1.start(currentTime);
                osc2.start(currentTime);
                osc3.start(currentTime + 0.3); // Delayed harmonic entry
                
                osc1.stop(currentTime + 3);
                osc2.stop(currentTime + 0.15); // Brief pulsar burst
                osc3.stop(currentTime + 3);
                
                console.log('📡 Radio telescope detecting deep space transmission...');
            }

            playCosmicAmbience() {
                if (!this.audioContext || !this.audioEnabled) return;
                
                // Generate continuous cosmic background ambience
                const ambienceGain = this.audioContext.createGain();
                const osc = this.audioContext.createOscillator();
                const filter = this.audioContext.createBiquadFilter();
                
                osc.connect(filter);
                filter.connect(ambienceGain);
                ambienceGain.connect(this.audioContext.destination);
                
                const currentTime = this.audioContext.currentTime;
                
                // Deep space humming
                osc.type = 'sine';
                osc.frequency.setValueAtTime(40, currentTime);
                
                // Low-pass filter for cosmic atmosphere
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, currentTime);
                filter.Q.setValueAtTime(0.5, currentTime);
                
                ambienceGain.gain.setValueAtTime(0.08, currentTime);
                
                osc.start(currentTime);
                
                // Auto-stop after 5 seconds to prevent audio buildup
                setTimeout(() => {
                    ambienceGain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1);
                    osc.stop(this.audioContext.currentTime + 1.1);
                }, 5000);
            }

            generateTerrain(chunkX, chunkZ) {
                const geometry = new THREE.PlaneGeometry(
                    this.chunkSize, 
                    this.chunkSize, 
                    64, 
                    64
                );
                
                const vertices = geometry.attributes.position.array;
                
                // Championship-level multi-octave procedural generation
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i] + chunkX * this.chunkSize;
                    const z = vertices[i + 2] + chunkZ * this.chunkSize;
                    
                    let height = this.generateHeight(x, z);
                    vertices[i + 1] = height;
                }
                
                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();
                
                // Dynamic material based on biome and world type
                const material = this.createTerrainMaterial(chunkX, chunkZ);
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(
                    chunkX * this.chunkSize,
                    0,
                    chunkZ * this.chunkSize
                );
                mesh.receiveShadow = true;
                mesh.castShadow = false;
                
                // Add procedural features
                this.addProceduralFeatures(mesh, chunkX, chunkZ);
                
                return mesh;
            }

            generateHeight(x, z) {
                let height = 0;
                const scaledX = x * 0.001;
                const scaledZ = z * 0.001;
                
                // Base terrain layer
                height += this.noise(scaledX * 0.5, scaledZ * 0.5) * 150;
                
                // Mountain layer
                height += this.noise(scaledX * 0.1, scaledZ * 0.1) * 80;
                
                // Hills layer
                height += this.noise(scaledX * 0.3, scaledZ * 0.3) * 40;
                
                // Detail layer
                height += this.noise(scaledX * 1.0, scaledZ * 1.0) * 15;
                
                // Fine details
                height += this.noise(scaledX * 3.0, scaledZ * 3.0) * 5;
                
                // World type modifications
                switch (this.worldType) {
                    case 'desert':
                        height = Math.abs(height) * 0.5 + 20;
                        break;
                    case 'canyon':
                        height = Math.pow(Math.abs(height), 1.5) * Math.sign(height);
                        break;
                    case 'coast':
                        height = height * 0.3 + Math.sin(scaledX * 10) * 10;
                        break;
                    case 'forest':
                        height = height * 0.8 + 30;
                        break;
                }
                
                return height;
            }

            createTerrainMaterial(chunkX, chunkZ) {
                const biomeNoise = this.noise(chunkX * 0.1, chunkZ * 0.1);
                let color;
                
                switch (this.worldType) {
                    case 'desert':
                        color = this.colors.primary;
                        break;
                    case 'forest':
                        color = this.colors.accent;
                        break;
                    case 'canyon':
                        color = 0xB7410E; // Canyon red
                        break;
                    case 'coast':
                        color = this.colors.secondary;
                        break;
                    default:
                        if (biomeNoise > 0.3) color = this.colors.primary;
                        else if (biomeNoise > 0) color = this.colors.secondary;
                        else if (biomeNoise > -0.3) color = this.colors.accent;
                        else color = this.colors.dark;
                }
                
                return new THREE.MeshLambertMaterial({
                    color: color,
                    wireframe: this.wireframe
                });
            }

            addProceduralFeatures(chunk, chunkX, chunkZ) {
                const featureCount = 15 + Math.random() * 25;
                
                for (let i = 0; i < featureCount; i++) {
                    const rand = Math.random();
                    
                    if (rand > 0.95) {
                        // Rare western landmarks
                        const landmark = this.createCosmicLandmark();
                        if (landmark) {
                            landmark.position.set(
                                (Math.random() - 0.5) * this.chunkSize * 0.8,
                                this.getTerrainHeight(
                                    chunkX * this.chunkSize + (Math.random() - 0.5) * this.chunkSize * 0.8,
                                    chunkZ * this.chunkSize + (Math.random() - 0.5) * this.chunkSize * 0.8
                                ),
                                (Math.random() - 0.5) * this.chunkSize * 0.8
                            );
                            chunk.add(landmark);
                        }
                    } else if (rand > 0.6) {
                        // Desert vegetation
                        const tree = this.createTree();
                        tree.position.set(
                            (Math.random() - 0.5) * this.chunkSize,
                            this.getTerrainHeight(
                                chunkX * this.chunkSize + (Math.random() - 0.5) * this.chunkSize,
                                chunkZ * this.chunkSize + (Math.random() - 0.5) * this.chunkSize
                            ),
                            (Math.random() - 0.5) * this.chunkSize
                        );
                        chunk.add(tree);
                    } else if (rand > 0.3) {
                        // Western rock formations
                        const rock = this.createRock();
                        rock.position.set(
                            (Math.random() - 0.5) * this.chunkSize,
                            this.getTerrainHeight(
                                chunkX * this.chunkSize + (Math.random() - 0.5) * this.chunkSize,
                                chunkZ * this.chunkSize + (Math.random() - 0.5) * this.chunkSize
                            ),
                            (Math.random() - 0.5) * this.chunkSize
                        );
                        chunk.add(rock);
                    } else if (rand > 0.1) {
                        // Desert shrubs and small details
                        const shrub = this.createDesertShrub();
                        shrub.position.set(
                            (Math.random() - 0.5) * this.chunkSize,
                            this.getTerrainHeight(
                                chunkX * this.chunkSize + (Math.random() - 0.5) * this.chunkSize,
                                chunkZ * this.chunkSize + (Math.random() - 0.5) * this.chunkSize
                            ),
                            (Math.random() - 0.5) * this.chunkSize
                        );
                        chunk.add(shrub);
                    }
                }
            }

            createTree() {
                const group = new THREE.Group();
                
                if (this.worldType === 'cosmic') {
                    // Create cosmic crystal formations
                    const crystalHeight = 8 + Math.random() * 12;
                    const crystalGeometry = new THREE.ConeGeometry(
                        2.5, 
                        crystalHeight, 
                        8
                    );
                    const crystalMaterial = new THREE.MeshLambertMaterial({ 
                        color: this.colors.accent, // Stellar cyan
                        transparent: true,
                        opacity: 0.8,
                        emissive: this.colors.accent,
                        emissiveIntensity: 0.2
                    });
                    const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                    crystal.position.y = crystalHeight / 2;
                    crystal.castShadow = true;
                    crystal.rotation.y = Math.random() * Math.PI * 2;
                    group.add(crystal);
                    
                    // Add smaller crystal shards randomly
                    if (Math.random() > 0.6) {
                        const shardGeometry = new THREE.ConeGeometry(1, 4, 6);
                        const shard = new THREE.Mesh(shardGeometry, crystalMaterial);
                        shard.position.set(2, crystalHeight * 0.7, 1);
                        shard.rotation.z = Math.PI / 6;
                        shard.castShadow = true;
                        group.add(shard);
                    }
                    
                    if (Math.random() > 0.7) {
                        const shardGeometry = new THREE.ConeGeometry(0.8, 3, 6);
                        const shard = new THREE.Mesh(shardGeometry, crystalMaterial);
                        shard.position.set(-1.5, crystalHeight * 0.6, -0.5);
                        shard.rotation.z = -Math.PI / 8;
                        shard.castShadow = true;
                        group.add(shard);
                    }
                } else {
                    // Regular tree for other biomes
                    const trunkHeight = 15 + Math.random() * 15;
                    const trunkGeometry = new THREE.CylinderGeometry(
                        1 + Math.random() * 2, 
                        2 + Math.random() * 3, 
                        trunkHeight, 
                        8
                    );
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = trunkHeight / 2;
                    trunk.castShadow = true;
                    group.add(trunk);
                    
                    // Foliage
                    const foliageGeometry = new THREE.SphereGeometry(
                        8 + Math.random() * 6, 
                        8, 
                        8
                    );
                    const foliageMaterial = new THREE.MeshLambertMaterial({ 
                        color: this.colors.accent 
                    });
                    const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                    foliage.position.y = trunkHeight + 8;
                    foliage.castShadow = true;
                    group.add(foliage);
                }
                
                return group;
            }

            createRock() {
                const size = 2 + Math.random() * 4;
                const geometry = new THREE.DodecahedronGeometry(size, 0);
                
                // Cosmic asteroid colors based on world type
                let rockColor;
                if (this.worldType === 'cosmic') {
                    const cosmicAsteroidColors = [
                        0x6B46C1, // Cosmic purple
                        0x3B82F6, // Nebula blue
                        0x8B5CF6, // Violet
                        0x06B6D4, // Stellar cyan
                        0x1E40AF  // Deep blue
                    ];
                    rockColor = cosmicAsteroidColors[Math.floor(Math.random() * cosmicAsteroidColors.length)];
                } else {
                    rockColor = this.colors.graphite;
                }
                
                const material = new THREE.MeshLambertMaterial({ 
                    color: rockColor 
                });
                const rock = new THREE.Mesh(geometry, material);
                rock.castShadow = true;
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                return rock;
            }

            createCosmicLandmark() {
                const landmarkTypes = [
                    'spaceStation',
                    'alienMonolith',
                    'wormholePortal',
                    'wreckedShip',
                    'quantumBeacon',
                    'nebulaPortal',
                    'alienOutpost',
                    'crystalFormation',
                    'blackHoleSingularity'
                ];
                
                const type = landmarkTypes[Math.floor(Math.random() * landmarkTypes.length)];
                const landmark = this.createLandmarkByType(type);
                
                // Add landmark data for discovery system
                if (landmark) {
                    landmark.userData = {
                        landmarkType: type,
                        discovered: false,
                        discoveryRadius: 25
                    };
                }
                
                return landmark;
            }

            createLandmarkByType(type) {
                switch (type) {
                    case 'spaceStation':
                        return this.createSpaceStation();
                    case 'alienMonolith':
                        return this.createAlienMonolith();
                    case 'wormholePortal':
                        return this.createWormholePortal();
                    case 'wreckedShip':
                        return this.createWreckedShip();
                    case 'quantumBeacon':
                        return this.createQuantumBeacon();
                    case 'nebulaPortal':
                        return this.createNebulaPortal();
                    case 'alienOutpost':
                        return this.createAlienOutpost();
                    case 'crystalFormation':
                        return this.createCrystalFormation();
                    case 'blackHoleSingularity':
                        return this.createBlackHoleSingularity();
                    default:
                        return null;
                }
            }

            checkLandmarkDiscovery() {
                // Check all chunks for undiscovered landmarks
                this.chunks.forEach(chunk => {
                    chunk.children.forEach(child => {
                        if (child.userData && child.userData.landmarkType && !child.userData.discovered) {
                            const distance = this.playerPosition.distanceTo(child.position);
                            
                            if (distance < child.userData.discoveryRadius) {
                                child.userData.discovered = true;
                                this.discoveredLandmarks.add(child.userData.landmarkType);
                                
                                // Trigger landmark discovery narrative and audio
                                this.displayNarrative('landmark_discovery');
                                
                                // Play environmental sounds based on landmark type
                                this.playLandmarkSound(child.userData.landmarkType);
                                
                                console.log(`🏛️ Discovered: ${child.userData.landmarkType}`);
                            }
                        }
                    });
                });
            }

            playLandmarkSound(landmarkType) {
                if (!this.audioContext || !this.audioEnabled) return;
                
                // Play contextual sounds for different landmark types
                switch (landmarkType) {
                    case 'westernWell':
                        this.playWellSound();
                        break;
                    case 'oldWagon':
                        this.playCreakingWoodSound();
                        break;
                    case 'goldMinersCamp':
                        this.playPickaxeSound();
                        break;
                    case 'cattleBones':
                        // Play distant wind through bones
                        this.playBoneWindSound();
                        break;
                    default:
                        // Generic discovery sound
                        this.playDiscoverySound();
                }
            }

            playWellSound() {
                // Water drop echo sound
                const dropGain = this.audioContext.createGain();
                const osc = this.audioContext.createOscillator();
                
                osc.connect(dropGain);
                dropGain.connect(this.audioContext.destination);
                
                osc.type = 'sine';
                const currentTime = this.audioContext.currentTime;
                
                osc.frequency.setValueAtTime(800, currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, currentTime + 0.3);
                
                dropGain.gain.setValueAtTime(0.2, currentTime);
                dropGain.gain.exponentialRampToValueAtTime(0.001, currentTime + 1);
                
                osc.start(currentTime);
                osc.stop(currentTime + 1);
            }

            playCreakingWoodSound() {
                // Creaking wood sound
                const creakGain = this.audioContext.createGain();
                const noise = this.audioContext.createBufferSource();
                
                // Create wood creak buffer
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 2, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.1 * Math.sin(i * 0.001);
                }
                
                noise.buffer = buffer;
                noise.connect(creakGain);
                creakGain.connect(this.audioContext.destination);
                
                const currentTime = this.audioContext.currentTime;
                creakGain.gain.setValueAtTime(0.15, currentTime);
                creakGain.gain.linearRampToValueAtTime(0, currentTime + 2);
                
                noise.start(currentTime);
                noise.stop(currentTime + 2);
            }

            playPickaxeSound() {
                // Metal on rock sound
                const pickGain = this.audioContext.createGain();
                const osc1 = this.audioContext.createOscillator();
                const osc2 = this.audioContext.createOscillator();
                
                osc1.connect(pickGain);
                osc2.connect(pickGain);
                pickGain.connect(this.audioContext.destination);
                
                osc1.type = 'square';
                osc2.type = 'sawtooth';
                
                const currentTime = this.audioContext.currentTime;
                
                osc1.frequency.setValueAtTime(1000, currentTime);
                osc1.frequency.exponentialRampToValueAtTime(100, currentTime + 0.1);
                
                osc2.frequency.setValueAtTime(2000, currentTime);
                osc2.frequency.exponentialRampToValueAtTime(200, currentTime + 0.1);
                
                pickGain.gain.setValueAtTime(0.2, currentTime);
                pickGain.gain.exponentialRampToValueAtTime(0.001, currentTime + 0.2);
                
                osc1.start(currentTime);
                osc2.start(currentTime);
                osc1.stop(currentTime + 0.2);
                osc2.stop(currentTime + 0.2);
            }

            playBoneWindSound() {
                // Haunting wind through bones
                const boneGain = this.audioContext.createGain();
                const osc = this.audioContext.createOscillator();
                
                osc.connect(boneGain);
                boneGain.connect(this.audioContext.destination);
                
                osc.type = 'sawtooth';
                const currentTime = this.audioContext.currentTime;
                
                osc.frequency.setValueAtTime(150, currentTime);
                osc.frequency.linearRampToValueAtTime(300, currentTime + 2);
                osc.frequency.linearRampToValueAtTime(100, currentTime + 4);
                
                boneGain.gain.setValueAtTime(0, currentTime);
                boneGain.gain.linearRampToValueAtTime(0.08, currentTime + 1);
                boneGain.gain.linearRampToValueAtTime(0, currentTime + 4);
                
                osc.start(currentTime);
                osc.stop(currentTime + 4);
            }

            playDiscoverySound() {
                // Generic mystical discovery sound
                const discGain = this.audioContext.createGain();
                const osc = this.audioContext.createOscillator();
                
                osc.connect(discGain);
                discGain.connect(this.audioContext.destination);
                
                osc.type = 'sine';
                const currentTime = this.audioContext.currentTime;
                
                osc.frequency.setValueAtTime(440, currentTime);
                osc.frequency.linearRampToValueAtTime(880, currentTime + 0.5);
                osc.frequency.linearRampToValueAtTime(660, currentTime + 1);
                
                discGain.gain.setValueAtTime(0.1, currentTime);
                discGain.gain.linearRampToValueAtTime(0, currentTime + 1);
                
                osc.start(currentTime);
                osc.stop(currentTime + 1);
            }

            playAtmosphericWind() {
                if (!this.audioContext || !this.audioEnabled) return;
                
                // Create atmospheric wind for weather transitions
                const windGain = this.audioContext.createGain();
                const noise = this.audioContext.createBufferSource();
                
                // Create wind buffer
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 6, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.2 * Math.sin(i * 0.0001);
                }
                
                noise.buffer = buffer;
                noise.connect(windGain);
                windGain.connect(this.audioContext.destination);
                
                const currentTime = this.audioContext.currentTime;
                windGain.gain.setValueAtTime(0, currentTime);
                windGain.gain.linearRampToValueAtTime(0.1, currentTime + 2);
                windGain.gain.linearRampToValueAtTime(0.15, currentTime + 3);
                windGain.gain.linearRampToValueAtTime(0, currentTime + 6);
                
                noise.start(currentTime);
                noise.stop(currentTime + 6);
                
                console.log('🌪️ Atmospheric wind for hill country weather transition');
            }

            createSpaceStation() {
                const group = new THREE.Group();
                
                // Main station core
                const coreGeometry = new THREE.CylinderGeometry(8, 8, 15, 16);
                const coreMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.light,
                    emissive: this.colors.primary,
                    emissiveIntensity: 0.1
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.position.y = 8;
                core.castShadow = true;
                core.receiveShadow = true;
                group.add(core);
                
                // Station dome
                const domeGeometry = new THREE.SphereGeometry(6, 16, 16);
                const domeMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.secondary,
                    transparent: true,
                    opacity: 0.7,
                    emissive: this.colors.secondary,
                    emissiveIntensity: 0.1
                });
                const dome = new THREE.Mesh(domeGeometry, domeMaterial);
                dome.position.y = 16;
                dome.castShadow = true;
                group.add(dome);
                
                // Docking bay
                const bayGeometry = new THREE.BoxGeometry(4, 3, 1);
                const bayMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.accent,
                    emissive: this.colors.accent,
                    emissiveIntensity: 0.2
                });
                const bay = new THREE.Mesh(bayGeometry, bayMaterial);
                bay.position.set(9, 8, 0);
                bay.castShadow = true;
                group.add(bay);
                
                // Communication arrays
                for (let i = 0; i < 4; i++) {
                    const arrayGeometry = new THREE.CylinderGeometry(0.2, 0.5, 8, 6);
                    const array = new THREE.Mesh(arrayGeometry, coreMaterial);
                    array.position.set(
                        Math.cos(i * Math.PI / 2) * 12,
                        12,
                        Math.sin(i * Math.PI / 2) * 12
                    );
                    array.rotation.z = (Math.random() - 0.5) * 0.3;
                    array.castShadow = true;
                    group.add(array);
                }
                
                return group;
            }

            createAlienMonolith() {
                const group = new THREE.Group();
                
                // Main monolith structure
                const monolithGeometry = new THREE.BoxGeometry(4, 25, 2);
                const monolithMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.dark,
                    emissive: this.colors.primary,
                    emissiveIntensity: 0.4
                });
                const monolith = new THREE.Mesh(monolithGeometry, monolithMaterial);
                monolith.position.y = 12.5;
                monolith.castShadow = true;
                monolith.receiveShadow = true;
                group.add(monolith);
                
                // Floating energy orbs around monolith
                for (let i = 0; i < 6; i++) {
                    const orbGeometry = new THREE.SphereGeometry(0.8, 8, 8);
                    const orbMaterial = new THREE.MeshLambertMaterial({ 
                        color: this.colors.accent,
                        emissive: this.colors.accent,
                        emissiveIntensity: 0.6,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    orb.position.set(
                        Math.cos(angle) * 6,
                        8 + Math.sin(angle * 2) * 2,
                        Math.sin(angle) * 6
                    );
                    orb.castShadow = true;
                    group.add(orb);
                }
                
                // Base platform
                const baseGeometry = new THREE.CylinderGeometry(8, 10, 2, 8);
                const baseMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.secondary,
                    emissive: this.colors.secondary,
                    emissiveIntensity: 0.1
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 1;
                base.castShadow = true;
                base.receiveShadow = true;
                group.add(base);
                
                return group;
            }

            createWormholePortal() {
                const group = new THREE.Group();
                
                // Central wormhole ring structure
                const ringGeometry = new THREE.TorusGeometry(12, 2, 16, 100);
                const ringMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.primary,
                    emissive: this.colors.primary,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                const centralRing = new THREE.Mesh(ringGeometry, ringMaterial);
                centralRing.position.y = 15;
                centralRing.rotation.x = Math.PI / 2;
                centralRing.castShadow = true;
                group.add(centralRing);
                
                // Inner wormhole event horizon
                const horizonGeometry = new THREE.CircleGeometry(10, 32);
                const horizonMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.dark,
                    emissive: this.colors.secondary,
                    emissiveIntensity: 1.2,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                const eventHorizon = new THREE.Mesh(horizonGeometry, horizonMaterial);
                eventHorizon.position.y = 15;
                eventHorizon.rotation.x = Math.PI / 2;
                group.add(eventHorizon);
                
                // Swirling energy field particles
                const particleCount = 200;
                const particleGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                
                for (let i = 0; i < particleCount; i++) {
                    const radius = Math.random() * 12 + 2;
                    const angle = Math.random() * Math.PI * 2;
                    const height = (Math.random() - 0.5) * 4;
                    
                    positions[i * 3] = Math.cos(angle) * radius;
                    positions[i * 3 + 1] = 15 + height;
                    positions[i * 3 + 2] = Math.sin(angle) * radius;
                    
                    // Color particles based on distance from center
                    const distanceRatio = radius / 14;
                    const color = new THREE.Color();
                    if (distanceRatio < 0.3) {
                        color.setHex(this.colors.accent); // Stellar cyan center
                    } else if (distanceRatio < 0.7) {
                        color.setHex(this.colors.secondary); // Nebula blue middle
                    } else {
                        color.setHex(this.colors.primary); // Cosmic purple outer
                    }
                    
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    
                    sizes[i] = Math.random() * 3 + 1;
                }
                
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const particleMaterial = new THREE.PointsMaterial({
                    size: 2,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.8,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending
                });
                
                const swirlingParticles = new THREE.Points(particleGeometry, particleMaterial);
                group.add(swirlingParticles);
                
                // Store particle system for animation
                group.userData.particleSystem = swirlingParticles;
                group.userData.particleCount = particleCount;
                group.userData.rotationSpeed = 0.02;
                
                // Outer stabilizing rings
                for (let i = 0; i < 3; i++) {
                    const outerRingGeometry = new THREE.TorusGeometry(16 + i * 3, 0.8, 8, 64);
                    const outerRingMaterial = new THREE.MeshLambertMaterial({ 
                        color: this.colors.accent,
                        emissive: this.colors.accent,
                        emissiveIntensity: 0.4 - i * 0.1,
                        transparent: true,
                        opacity: 0.6 - i * 0.1
                    });
                    const outerRing = new THREE.Mesh(outerRingGeometry, outerRingMaterial);
                    outerRing.position.y = 15;
                    outerRing.rotation.x = Math.PI / 2;
                    outerRing.rotation.z = i * (Math.PI / 3);
                    group.add(outerRing);
                }
                
                // Quantum field distortion effect around base
                const baseGeometry = new THREE.CylinderGeometry(18, 20, 3, 32);
                const baseMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.dark,
                    emissive: this.colors.primary,
                    emissiveIntensity: 0.2,
                    transparent: true,
                    opacity: 0.3
                });
                const quantumBase = new THREE.Mesh(baseGeometry, baseMaterial);
                quantumBase.position.y = 1.5;
                quantumBase.castShadow = true;
                quantumBase.receiveShadow = true;
                group.add(quantumBase);
                
                // Energy pillars supporting the portal
                for (let i = 0; i < 4; i++) {
                    const pillarGeometry = new THREE.CylinderGeometry(1, 1.5, 12, 8);
                    const pillarMaterial = new THREE.MeshLambertMaterial({ 
                        color: this.colors.graphite,
                        emissive: this.colors.secondary,
                        emissiveIntensity: 0.5
                    });
                    const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                    const angle = (i / 4) * Math.PI * 2;
                    pillar.position.set(
                        Math.cos(angle) * 22,
                        6,
                        Math.sin(angle) * 22
                    );
                    pillar.castShadow = true;
                    group.add(pillar);
                    
                    // Energy beam from pillar to portal
                    const beamGeometry = new THREE.CylinderGeometry(0.2, 0.2, 12, 6);
                    const beamMaterial = new THREE.MeshLambertMaterial({ 
                        color: this.colors.accent,
                        emissive: this.colors.accent,
                        emissiveIntensity: 1.0,
                        transparent: true,
                        opacity: 0.8
                    });
                    const energyBeam = new THREE.Mesh(beamGeometry, beamMaterial);
                    energyBeam.position.set(
                        Math.cos(angle) * 17,
                        15,
                        Math.sin(angle) * 17
                    );
                    
                    // Point beam toward center
                    energyBeam.lookAt(0, 15, 0);
                    energyBeam.rotateX(Math.PI / 2);
                    group.add(energyBeam);
                }
                
                return group;
            }

            createWreckedShip() {
                const group = new THREE.Group();
                
                // Main hull (broken)
                const hullGeometry = new THREE.BoxGeometry(15, 4, 6);
                const hullMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.graphite,
                    emissive: 0x440000,
                    emissiveIntensity: 0.1
                });
                const hull = new THREE.Mesh(hullGeometry, hullMaterial);
                hull.position.y = 2;
                hull.rotation.z = 0.3; // Crashed at angle
                hull.castShadow = true;
                group.add(hull);
                
                // Wagon wheels
                const wheelGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.5, 8);
                const wheelMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x654321 
                });
                
                // Front wheels
                const wheel1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel1.position.set(-3, 1.5, -2.5);
                wheel1.rotation.z = Math.PI / 2;
                wheel1.castShadow = true;
                group.add(wheel1);
                
                const wheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel2.position.set(-3, 1.5, 2.5);
                wheel2.rotation.z = Math.PI / 2;
                wheel2.castShadow = true;
                group.add(wheel2);
                
                // Back wheels
                const wheel3 = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel3.position.set(3, 1.5, -2.5);
                wheel3.rotation.z = Math.PI / 2;
                wheel3.castShadow = true;
                group.add(wheel3);
                
                const wheel4 = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel4.position.set(3, 1.5, 2.5);
                wheel4.rotation.z = Math.PI / 2;
                wheel4.castShadow = true;
                group.add(wheel4);
                
                // Broken wagon tongue
                const tongueGeometry = new THREE.BoxGeometry(6, 0.5, 0.5);
                const tongue = new THREE.Mesh(tongueGeometry, bedMaterial);
                tongue.position.set(-7, 2, 0);
                tongue.rotation.z = -0.2;
                tongue.castShadow = true;
                group.add(tongue);
                
                return group;
            }

            createWeatheredCross() {
                const group = new THREE.Group();
                
                // Vertical beam
                const verticalGeometry = new THREE.BoxGeometry(0.8, 8, 0.8);
                const crossMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B7355 // Weathered wood
                });
                const vertical = new THREE.Mesh(verticalGeometry, crossMaterial);
                vertical.position.y = 4;
                vertical.castShadow = true;
                group.add(vertical);
                
                // Horizontal beam
                const horizontalGeometry = new THREE.BoxGeometry(4, 0.8, 0.8);
                const horizontal = new THREE.Mesh(horizontalGeometry, crossMaterial);
                horizontal.position.y = 6;
                horizontal.castShadow = true;
                group.add(horizontal);
                
                // Small memorial stones around base
                for (let i = 0; i < 6; i++) {
                    const stoneGeometry = new THREE.DodecahedronGeometry(0.3 + Math.random() * 0.5, 0);
                    const stoneMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x696969 
                    });
                    const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    stone.position.set(
                        Math.cos(angle) * (1.5 + Math.random()),
                        0.2,
                        Math.sin(angle) * (1.5 + Math.random())
                    );
                    stone.castShadow = true;
                    group.add(stone);
                }
                
                return group;
            }

            createCanyonArch() {
                const group = new THREE.Group();
                
                // Left pillar
                const pillarGeometry = new THREE.BoxGeometry(3, 12, 4);
                const pillarMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xCD853F // Peru (sandstone)
                });
                const leftPillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                leftPillar.position.set(-6, 6, 0);
                leftPillar.castShadow = true;
                leftPillar.receiveShadow = true;
                group.add(leftPillar);
                
                // Right pillar
                const rightPillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                rightPillar.position.set(6, 6, 0);
                rightPillar.castShadow = true;
                rightPillar.receiveShadow = true;
                group.add(rightPillar);
                
                // Arch top
                const archGeometry = new THREE.CylinderGeometry(1.5, 1.5, 12, 8, 1, false, 0, Math.PI);
                const arch = new THREE.Mesh(archGeometry, pillarMaterial);
                arch.position.y = 12;
                arch.rotation.z = Math.PI / 2;
                arch.castShadow = true;
                group.add(arch);
                
                return group;
            }

            createIndianTepee() {
                const group = new THREE.Group();
                
                // Main tepee structure
                const tepeeGeometry = new THREE.ConeGeometry(4, 8, 8);
                const tepeeMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xF5DEB3 // Wheat (hide color)
                });
                const tepee = new THREE.Mesh(tepeeGeometry, tepeeMaterial);
                tepee.position.y = 4;
                tepee.castShadow = true;
                group.add(tepee);
                
                // Support poles sticking out the top
                for (let i = 0; i < 6; i++) {
                    const poleGeometry = new THREE.CylinderGeometry(0.1, 0.15, 10, 6);
                    const poleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x8B4513 
                    });
                    const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    pole.position.set(
                        Math.cos(angle) * 2,
                        8,
                        Math.sin(angle) * 2
                    );
                    pole.rotation.z = Math.cos(angle) * 0.2;
                    pole.rotation.x = Math.sin(angle) * 0.2;
                    pole.castShadow = true;
                    group.add(pole);
                }
                
                // Fire pit in front
                const pitGeometry = new THREE.CylinderGeometry(1.5, 1.8, 0.5, 12);
                const pitMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x2F1B14 // Dark brown earth
                });
                const pit = new THREE.Mesh(pitGeometry, pitMaterial);
                pit.position.set(0, 0.25, 6);
                group.add(pit);
                
                return group;
            }

            createGoldMinersCamp() {
                const group = new THREE.Group();
                
                // Mining equipment - wooden frame
                const frameGeometry = new THREE.BoxGeometry(0.5, 6, 0.5);
                const frameMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513 
                });
                
                const support1 = new THREE.Mesh(frameGeometry, frameMaterial);
                support1.position.set(-2, 3, 0);
                support1.rotation.z = 0.3;
                support1.castShadow = true;
                group.add(support1);
                
                const support2 = new THREE.Mesh(frameGeometry, frameMaterial);
                support2.position.set(2, 3, 0);
                support2.rotation.z = -0.3;
                support2.castShadow = true;
                group.add(support2);
                
                // Sluice box
                const sluiceGeometry = new THREE.BoxGeometry(8, 1, 2);
                const sluiceMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x654321 
                });
                const sluice = new THREE.Mesh(sluiceGeometry, sluiceMaterial);
                sluice.position.set(0, 1, 4);
                sluice.rotation.x = 0.1;
                sluice.castShadow = true;
                group.add(sluice);
                
                // Scattered mining tools and rocks
                for (let i = 0; i < 8; i++) {
                    const toolSize = 0.5 + Math.random() * 1;
                    const toolGeometry = new THREE.BoxGeometry(toolSize, 0.3, 0.3);
                    const tool = new THREE.Mesh(toolGeometry, frameMaterial);
                    tool.position.set(
                        (Math.random() - 0.5) * 10,
                        0.2,
                        (Math.random() - 0.5) * 8
                    );
                    tool.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    tool.castShadow = true;
                    group.add(tool);
                }
                
                return group;
            }

            createCattleBones() {
                const group = new THREE.Group();
                
                // Large skull
                const skullGeometry = new THREE.BoxGeometry(3, 2, 2);
                const boneMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xF5F5DC // Beige (old bone)
                });
                const skull = new THREE.Mesh(skullGeometry, boneMaterial);
                skull.position.y = 1;
                skull.castShadow = true;
                group.add(skull);
                
                // Horn sockets
                const hornGeometry = new THREE.ConeGeometry(0.3, 2, 6);
                const horn1 = new THREE.Mesh(hornGeometry, boneMaterial);
                horn1.position.set(-1.2, 2, 0.5);
                horn1.rotation.z = -0.5;
                horn1.castShadow = true;
                group.add(horn1);
                
                const horn2 = new THREE.Mesh(hornGeometry, boneMaterial);
                horn2.position.set(1.2, 2, 0.5);
                horn2.rotation.z = 0.5;
                horn2.castShadow = true;
                group.add(horn2);
                
                // Scattered rib bones
                for (let i = 0; i < 12; i++) {
                    const ribGeometry = new THREE.CylinderGeometry(0.1, 0.15, 2 + Math.random(), 6);
                    const rib = new THREE.Mesh(ribGeometry, boneMaterial);
                    rib.position.set(
                        (Math.random() - 0.5) * 8,
                        0.1,
                        (Math.random() - 0.5) * 6
                    );
                    rib.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    rib.castShadow = true;
                    group.add(rib);
                }
                
                return group;
            }

            createDesertShrub() {
                const group = new THREE.Group();
                
                const shrubTypes = ['sagebrush', 'tumbleweed', 'pricklypear', 'yucca'];
                const type = shrubTypes[Math.floor(Math.random() * shrubTypes.length)];
                
                switch (type) {
                    case 'sagebrush':
                        const sageGeometry = new THREE.SphereGeometry(1 + Math.random() * 1.5, 6, 4);
                        const sageMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x9ACD32 // Yellow green
                        });
                        const sage = new THREE.Mesh(sageGeometry, sageMaterial);
                        sage.position.y = 1;
                        sage.scale.y = 0.6;
                        sage.castShadow = true;
                        group.add(sage);
                        break;
                        
                    case 'tumbleweed':
                        const tumbleGeometry = new THREE.SphereGeometry(1.5 + Math.random(), 8, 6);
                        const tumbleMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xDEB887, // Burlywood
                            transparent: true,
                            opacity: 0.7
                        });
                        const tumble = new THREE.Mesh(tumbleGeometry, tumbleMaterial);
                        tumble.position.y = 1.5;
                        tumble.castShadow = true;
                        group.add(tumble);
                        break;
                        
                    case 'pricklypear':
                        for (let i = 0; i < 3; i++) {
                            const padGeometry = new THREE.SphereGeometry(0.8 + Math.random() * 0.5, 6, 4);
                            const padMaterial = new THREE.MeshLambertMaterial({ 
                                color: 0x228B22 
                            });
                            const pad = new THREE.Mesh(padGeometry, padMaterial);
                            pad.position.set(
                                (Math.random() - 0.5) * 2,
                                0.5 + i * 0.8,
                                (Math.random() - 0.5) * 2
                            );
                            pad.scale.y = 0.3;
                            pad.castShadow = true;
                            group.add(pad);
                        }
                        break;
                        
                    case 'yucca':
                        // Yucca trunk
                        const yuccaTrunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 2, 8);
                        const yuccaTrunkMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x8B4513 
                        });
                        const yuccaTrunk = new THREE.Mesh(yuccaTrunkGeometry, yuccaTrunkMaterial);
                        yuccaTrunk.position.y = 1;
                        yuccaTrunk.castShadow = true;
                        group.add(yuccaTrunk);
                        
                        // Yucca leaves
                        for (let i = 0; i < 8; i++) {
                            const leafGeometry = new THREE.BoxGeometry(0.1, 3, 0.1);
                            const leafMaterial = new THREE.MeshLambertMaterial({ 
                                color: 0x556B2F // Dark olive green
                            });
                            const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                            const angle = (i / 8) * Math.PI * 2;
                            leaf.position.set(
                                Math.cos(angle) * 0.8,
                                2.5,
                                Math.sin(angle) * 0.8
                            );
                            leaf.rotation.y = angle;
                            leaf.rotation.x = -0.3;
                            leaf.castShadow = true;
                            group.add(leaf);
                        }
                        break;
                }
                
                return group;
            }

            createPlayerCharacter() {
                this.playerCharacter = new THREE.Group();
                
                // Space Suit Body
                const bodyGeometry = new THREE.CylinderGeometry(0.9, 1.1, 3.2, 12);
                const bodyMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.light, // Pristine white space suit
                    emissive: this.colors.primary,
                    emissiveIntensity: 0.05
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 2;
                body.castShadow = true;
                this.playerCharacter.add(body);
                
                // Life Support Chest Panel
                const chestPanelGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.15);
                const chestPanelMaterial = new THREE.MeshLambertMaterial({
                    color: this.colors.graphite,
                    emissive: this.colors.accent,
                    emissiveIntensity: 0.3
                });
                const chestPanel = new THREE.Mesh(chestPanelGeometry, chestPanelMaterial);
                chestPanel.position.set(0, 2.5, 1.05);
                chestPanel.castShadow = true;
                this.playerCharacter.add(chestPanel);
                
                // Space Helmet
                const helmetGeometry = new THREE.SphereGeometry(1.1, 16, 12);
                const helmetMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.light,
                    transparent: true,
                    opacity: 0.3,
                    emissive: this.colors.secondary,
                    emissiveIntensity: 0.1
                });
                const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
                helmet.position.y = 4.4;
                helmet.castShadow = true;
                this.playerCharacter.add(helmet);
                
                // Helmet Visor (darker inner sphere for visibility)
                const visorGeometry = new THREE.SphereGeometry(0.9, 16, 12);
                const visorMaterial = new THREE.MeshLambertMaterial({
                    color: this.colors.dark,
                    transparent: true,
                    opacity: 0.7,
                    emissive: this.colors.primary,
                    emissiveIntensity: 0.2
                });
                const visor = new THREE.Mesh(visorGeometry, visorMaterial);
                visor.position.y = 4.4;
                this.playerCharacter.add(visor);
                
                // Helmet Communication Antenna
                const antennaGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 6);
                const antennaMaterial = new THREE.MeshLambertMaterial({
                    color: this.colors.accent,
                    emissive: this.colors.accent,
                    emissiveIntensity: 0.4
                });
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.set(0.8, 5.0, 0);
                antenna.rotation.z = -0.3;
                this.playerCharacter.add(antenna);
                
                // Space Suit Arms
                const armGeometry = new THREE.CylinderGeometry(0.35, 0.45, 2.8, 10);
                const armMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.light,
                    emissive: this.colors.primary,
                    emissiveIntensity: 0.03
                });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-1.4, 2.8, 0);
                leftArm.rotation.z = 0.3;
                leftArm.castShadow = true;
                this.playerCharacter.add(leftArm);
                
                // Left Arm Joint/Glove
                const gloveGeometry = new THREE.SphereGeometry(0.4, 8, 6);
                const gloveMaterial = new THREE.MeshLambertMaterial({
                    color: this.colors.graphite,
                    emissive: this.colors.accent,
                    emissiveIntensity: 0.2
                });
                const leftGlove = new THREE.Mesh(gloveGeometry, gloveMaterial);
                leftGlove.position.set(-1.8, 1.5, 0);
                this.playerCharacter.add(leftGlove);
                
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(1.4, 2.8, 0);
                rightArm.rotation.z = -0.3;
                rightArm.castShadow = true;
                this.playerCharacter.add(rightArm);
                
                const rightGlove = new THREE.Mesh(gloveGeometry, gloveMaterial);
                rightGlove.position.set(1.8, 1.5, 0);
                this.playerCharacter.add(rightGlove);
                
                // Space Suit Legs
                const legGeometry = new THREE.CylinderGeometry(0.45, 0.55, 3.0, 10);
                const legMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.light,
                    emissive: this.colors.primary,
                    emissiveIntensity: 0.03
                });
                
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                leftLeg.position.set(-0.6, -0.4, 0);
                leftLeg.castShadow = true;
                this.playerCharacter.add(leftLeg);
                
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                rightLeg.position.set(0.6, -0.4, 0);
                rightLeg.castShadow = true;
                this.playerCharacter.add(rightLeg);
                
                // Space Boots with Magnetic Attachment Systems
                const bootGeometry = new THREE.BoxGeometry(1.0, 0.6, 1.5);
                const bootMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.graphite,
                    emissive: this.colors.accent,
                    emissiveIntensity: 0.15
                });
                
                const leftBoot = new THREE.Mesh(bootGeometry, bootMaterial);
                leftBoot.position.set(-0.6, -1.7, 0.3);
                leftBoot.castShadow = true;
                this.playerCharacter.add(leftBoot);
                
                // Magnetic Boot Thrusters (small cylindrical attachments)
                const thrusterGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.3, 8);
                const thrusterMaterial = new THREE.MeshLambertMaterial({
                    color: this.colors.accent,
                    emissive: this.colors.accent,
                    emissiveIntensity: 0.6
                });
                
                const leftThruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
                leftThruster.position.set(-0.6, -1.9, 1.0);
                leftThruster.rotation.x = Math.PI / 2;
                this.playerCharacter.add(leftThruster);
                
                const rightBoot = new THREE.Mesh(bootGeometry, bootMaterial);
                rightBoot.position.set(0.6, -1.7, 0.3);
                rightBoot.castShadow = true;
                this.playerCharacter.add(rightBoot);
                
                const rightThruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
                rightThruster.position.set(0.6, -1.9, 1.0);
                rightThruster.rotation.x = Math.PI / 2;
                this.playerCharacter.add(rightThruster);
                
                // Oxygen Tank Backpack
                const backpackGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.8, 8);
                const backpackMaterial = new THREE.MeshLambertMaterial({
                    color: this.colors.secondary,
                    emissive: this.colors.secondary,
                    emissiveIntensity: 0.1
                });
                const backpack = new THREE.Mesh(backpackGeometry, backpackMaterial);
                backpack.position.set(0, 2.2, -1.2);
                backpack.castShadow = true;
                this.playerCharacter.add(backpack);
                
                // Backpack Warning Light
                const warningLightGeometry = new THREE.SphereGeometry(0.1, 8, 6);
                const warningLightMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFF4444,
                    emissive: 0xFF4444,
                    emissiveIntensity: 0.8
                });
                const warningLight = new THREE.Mesh(warningLightGeometry, warningLightMaterial);
                warningLight.position.set(0, 3.2, -1.2);
                this.playerCharacter.add(warningLight);
                
                // Multi-tool Utility Belt
                const beltGeometry = new THREE.TorusGeometry(1.2, 0.08, 8, 16);
                const beltMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.graphite,
                    emissive: this.colors.accent,
                    emissiveIntensity: 0.1
                });
                const belt = new THREE.Mesh(beltGeometry, beltMaterial);
                belt.position.set(0, 0.8, 0);
                belt.rotation.x = Math.PI / 2;
                belt.castShadow = true;
                this.playerCharacter.add(belt);
                
                // Plasma Tool Holster
                const holsterGeometry = new THREE.CylinderGeometry(0.2, 0.25, 1.2, 8);
                const holsterMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.secondary,
                    emissive: this.colors.secondary,
                    emissiveIntensity: 0.2
                });
                const holster = new THREE.Mesh(holsterGeometry, holsterMaterial);
                holster.position.set(1.3, 0.5, 0);
                holster.rotation.z = -0.3;
                holster.castShadow = true;
                this.playerCharacter.add(holster);
                
                this.playerCharacter.position.copy(this.playerPosition);
                this.playerCharacter.position.y += 3; // Lift above ground
                this.scene.add(this.playerCharacter);
                
                // Animation properties
                this.walkCycle = 0;
                this.isWalking = false;
                this.isRiding = false;
            }

            createSpacecraft() {
                this.spacecraft = new THREE.Group();
                
                // Spacecraft Main Hull
                const hullGeometry = new THREE.CylinderGeometry(1.8, 2.2, 8, 16);
                const hullMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.light, // Pristine spacecraft white
                    emissive: this.colors.primary,
                    emissiveIntensity: 0.1
                });
                const hull = new THREE.Mesh(hullGeometry, hullMaterial);
                hull.position.y = 4;
                hull.rotation.z = Math.PI / 2;
                hull.castShadow = true;
                this.spacecraft.add(hull);
                
                // Spacecraft Cockpit
                const cockpitGeometry = new THREE.SphereGeometry(1.5, 12, 8);
                const cockpitMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.secondary,
                    transparent: true,
                    opacity: 0.4,
                    emissive: this.colors.accent,
                    emissiveIntensity: 0.2
                });
                const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
                cockpit.position.set(3.5, 4.5, 0);
                cockpit.castShadow = true;
                this.spacecraft.add(cockpit);
                
                // Navigation Sensor Array
                const sensorGeometry = new THREE.ConeGeometry(0.6, 1.5, 8);
                const sensorMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.accent,
                    emissive: this.colors.accent,
                    emissiveIntensity: 0.4
                });
                const sensor = new THREE.Mesh(sensorGeometry, sensorMaterial);
                sensor.position.set(5, 4.2, 0);
                sensor.rotation.x = Math.PI / 2;
                sensor.castShadow = true;
                this.spacecraft.add(sensor);
                
                // Quantum Thrusters (main propulsion)
                const thrusterGeometry = new THREE.CylinderGeometry(0.8, 1.2, 2.5, 12);
                const thrusterMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.secondary,
                    emissive: this.colors.primary,
                    emissiveIntensity: 0.3
                });
                
                // Port thruster
                const portThruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
                portThruster.position.set(-2.5, 4, -2);
                portThruster.rotation.z = Math.PI / 2;
                portThruster.castShadow = true;
                this.spacecraft.add(portThruster);
                
                const starboardThruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
                starboardThruster.position.set(-2.5, 4, 2);
                starboardThruster.rotation.z = Math.PI / 2;
                starboardThruster.castShadow = true;
                this.spacecraft.add(starboardThruster);
                
                // Landing Stabilizers
                const stabilizerGeometry = new THREE.BoxGeometry(0.4, 3, 0.4);
                const stabilizerMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.graphite,
                    emissive: this.colors.accent,
                    emissiveIntensity: 0.1
                });
                
                // Four landing stabilizers
                const positions = [
                    { x: 2, y: 2, z: -1.8 },
                    { x: 2, y: 2, z: 1.8 },
                    { x: -2, y: 2, z: -1.8 },
                    { x: -2, y: 2, z: 1.8 }
                ];
                
                positions.forEach(pos => {
                    const stabilizer = new THREE.Mesh(stabilizerGeometry, stabilizerMaterial);
                    stabilizer.position.set(pos.x, pos.y, pos.z);
                    stabilizer.castShadow = true;
                    this.spacecraft.add(stabilizer);
                });
                
                // Plasma Energy Core (visible through transparent hull sections)
                const coreGeometry = new THREE.SphereGeometry(0.8, 12, 8);
                const coreMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.accent,
                    emissive: this.colors.accent,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.7
                });
                const energyCore = new THREE.Mesh(coreGeometry, coreMaterial);
                energyCore.position.set(0, 4, 0);
                energyCore.castShadow = true;
                this.spacecraft.add(energyCore);
                
                // Wing Solar Arrays
                for (let i = 0; i < 3; i++) {
                    const wingGeometry = new THREE.BoxGeometry(0.1, 2.5, 1.2);
                    const wingMaterial = new THREE.MeshLambertMaterial({ 
                        color: this.colors.secondary,
                        emissive: this.colors.primary,
                        emissiveIntensity: 0.2,
                        transparent: true,
                        opacity: 0.8
                    });
                    const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                    leftWing.position.set(-0.5 + i * 1, 5.5 - i * 0.3, -3);
                    leftWing.rotation.x = 0.2;
                    leftWing.castShadow = true;
                    this.spacecraft.add(leftWing);
                    
                    const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                    rightWing.position.set(-0.5 + i * 1, 5.5 - i * 0.3, 3);
                    rightWing.rotation.x = -0.2;
                    rightWing.castShadow = true;
                    this.spacecraft.add(rightWing);
                }
                
                // Command Bridge
                const bridgeGeometry = new THREE.BoxGeometry(2.5, 0.6, 3);
                const bridgeMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.primary,
                    emissive: this.colors.primary,
                    emissiveIntensity: 0.2
                });
                const bridge = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
                bridge.position.set(1, 5.5, 0);
                bridge.castShadow = true;
                this.spacecraft.add(bridge);
                
                // Communication Arrays
                const commGeometry = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 8);
                const commMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.colors.accent,
                    emissive: this.colors.accent,
                    emissiveIntensity: 0.5
                });
                const leftComm = new THREE.Mesh(commGeometry, commMaterial);
                leftComm.position.set(1.5, 6.2, -0.8);
                leftComm.rotation.z = 0.3;
                leftComm.castShadow = true;
                this.spacecraft.add(leftComm);
                
                const rightComm = new THREE.Mesh(commGeometry, commMaterial);
                rightComm.position.set(1.5, 6.2, 0.8);
                rightComm.rotation.z = -0.3;
                rightComm.castShadow = true;
                this.spacecraft.add(rightComm);
                
                // Position spacecraft near player (initially not visible)
                this.spacecraft.position.copy(this.playerPosition);
                this.spacecraft.position.x += 15; // Off to the side
                this.spacecraft.position.y = this.getTerrainHeight(this.spacecraft.position.x, this.spacecraft.position.z) + 5; // Hovering
                this.spacecraft.visible = false; // Hide until called
                this.scene.add(this.spacecraft);
                
                // Spacecraft animation properties
                this.spacecraftHoverCycle = 0;
                this.thrusterMode = 'idle'; // idle, cruise, boost
                this.energyCoreIntensity = 0.8;
            }

            toggleMount() {
                if (!this.isRiding) {
                    // Board spacecraft
                    const distanceToSpacecraft = this.playerPosition.distanceTo(this.spacecraft.position);
                    if (distanceToSpacecraft < 12) {
                        this.isRiding = true;
                        this.spacecraft.visible = true;
                        this.playerCharacter.visible = false;
                        this.spacecraft.position.copy(this.playerPosition);
                        this.spacecraft.position.y = this.getTerrainHeight(this.spacecraft.position.x, this.spacecraft.position.z) + 8; // Hovering height
                        this.speed = 200; // Faster in spacecraft
                        this.cameraOffset.set(0, 18, 35); // Adjust camera for spacecraft flight
                        this.thrusterMode = 'cruise';
                        this.playThrusterAudio();
                        console.log('🚀 Spacecraft boarded! Quantum thrusters online!');
                    } else {
                        console.log('🚀 Spacecraft too far away. Sending beacon to call your ship.');
                        this.callSpacecraft();
                    }
                } else {
                    // Disembark from spacecraft
                    this.isRiding = false;
                    this.spacecraft.position.y = this.getTerrainHeight(this.spacecraft.position.x, this.spacecraft.position.z) + 2; // Land the ship
                    this.playerCharacter.visible = true;
                    this.playerCharacter.position.copy(this.spacecraft.position);
                    this.playerCharacter.position.x += 4; // Disembark to the side
                    this.playerCharacter.position.y = this.getTerrainHeight(this.playerCharacter.position.x, this.playerCharacter.position.z) + 1;
                    this.playerPosition.copy(this.playerCharacter.position);
                    this.speed = 75; // Normal walking speed
                    this.cameraOffset.set(0, 20, 30); // Reset camera
                    this.thrusterMode = 'idle';
                    console.log('🧑‍🚀 Disembarked from spacecraft! Back on foot in the cosmic void.');
                }
            }

            callSpacecraft() {
                // Animate spacecraft hyperjumping to player with cosmic audio and narrative
                this.spacecraft.visible = true;
                const targetPosition = this.playerPosition.clone();
                targetPosition.x += 8;
                targetPosition.z += 8;
                targetPosition.y = this.getTerrainHeight(targetPosition.x, targetPosition.z) + 6; // Hovering arrival
                
                // Play quantum thruster activation sequence
                this.playThrusterSequence();
                
                // Display spacecraft call narrative
                this.displayNarrative('spacecraft_call');
                
                // Hyperjump animation - spacecraft warps to player location
                const startPosition = this.spacecraft.position.clone();
                const duration = 2500; // 2.5 seconds for hyperjump
                const startTime = Date.now();
                
                const animateSpacecraft = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Create warp effect - rapid acceleration then deceleration
                    const warpProgress = progress < 0.8 ? progress * 0.1 : (progress - 0.8) / 0.2;
                    
                    this.spacecraft.position.lerpVectors(startPosition, targetPosition, warpProgress);
                    
                    // Add quantum energy core pulsing during approach
                    if (this.spacecraft.children[6]) { // Energy core
                        this.spacecraft.children[6].material.emissiveIntensity = 0.8 + Math.sin(elapsed * 0.01) * 0.3;
                    }
                    
                    // Play thruster hum during movement
                    if (progress > 0.1 && progress < 0.9 && elapsed % 300 < 50) {
                        this.playThrusterHum();
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateSpacecraft);
                    } else {
                        console.log('🚀 Spacecraft has arrived via quantum hyperjump! Ready for cosmic exploration!');
                        // Reset energy core intensity
                        if (this.spacecraft.children[6]) {
                            this.spacecraft.children[6].material.emissiveIntensity = 0.8;
                        }
                    }
                };
                
                animateSpacecraft();
            }

            animateCharacters(delta) {
                if (!this.playerCharacter || !this.spacecraft) return;
                
                // Walking animation for character with authentic hill country footsteps
                if (this.isWalking && !this.isMounted) {
                    this.walkCycle += delta * 8;
                    
                    // Play footstep sounds on each step
                    const currentTime = Date.now();
                    const stepInterval = 500; // milliseconds between steps
                    if (currentTime - this.lastFootstepTime > stepInterval) {
                        this.playFootstepSound();
                        this.lastFootstepTime = currentTime;
                        
                        // Trigger exploration narrative occasionally
                        if (Math.random() < 0.03) {
                            this.displayNarrative('exploration');
                        }
                        
                        // Trigger radio telescope signals occasionally during cosmic exploration
                        if (Math.random() < 0.01) {
                            this.playRadioTelescopeSignal();
                        }
                    }
                    
                    // Animate arms swinging
                    const armSwing = Math.sin(this.walkCycle) * 0.3;
                    if (this.playerCharacter.children[4]) { // Left arm
                        this.playerCharacter.children[4].rotation.x = armSwing;
                    }
                    if (this.playerCharacter.children[5]) { // Right arm
                        this.playerCharacter.children[5].rotation.x = -armSwing;
                    }
                    
                    // Animate legs
                    const legSwing = Math.sin(this.walkCycle) * 0.2;
                    if (this.playerCharacter.children[6]) { // Left leg
                        this.playerCharacter.children[6].rotation.x = legSwing;
                    }
                    if (this.playerCharacter.children[7]) { // Right leg
                        this.playerCharacter.children[7].rotation.x = -legSwing;
                    }
                    
                    // Bob the whole character for authentic walking motion
                    this.playerCharacter.position.y = this.playerPosition.y + 3 + Math.abs(Math.sin(this.walkCycle * 2)) * 0.1;
                } else {
                    // Reset to idle pose
                    if (this.playerCharacter.children[4]) this.playerCharacter.children[4].rotation.x = 0.3;
                    if (this.playerCharacter.children[5]) this.playerCharacter.children[5].rotation.x = -0.3;
                    if (this.playerCharacter.children[6]) this.playerCharacter.children[6].rotation.x = 0;
                    if (this.playerCharacter.children[7]) this.playerCharacter.children[7].rotation.x = 0;
                    this.playerCharacter.position.y = this.playerPosition.y + 3;
                }
                
                // Spacecraft animation
                if (this.isRiding) {
                    this.spacecraftHoverCycle += delta * 4;
                    
                    // Animate spacecraft hovering with quantum stabilizers
                    this.spacecraft.position.y = this.getTerrainHeight(this.spacecraft.position.x, this.spacecraft.position.z) + 
                                               8 + Math.sin(this.spacecraftHoverCycle) * 0.5;
                    
                    // Animate energy core pulsing
                    if (this.spacecraft.children[6]) { // Energy core
                        this.spacecraft.children[6].material.emissiveIntensity = 0.8 + Math.sin(this.spacecraftHoverCycle * 2) * 0.2;
                    }
                    
                    // Animate communication arrays rotating
                    if (this.spacecraft.children[15]) { // Left comm array
                        this.spacecraft.children[15].rotation.y = Math.sin(this.spacecraftHoverCycle * 0.5) * 0.1;
                    }
                    if (this.spacecraft.children[16]) { // Right comm array
                        this.spacecraft.children[16].rotation.y = -Math.sin(this.spacecraftHoverCycle * 0.5) * 0.1;
                    }
                    
                    // Animate thruster glow based on movement
                    const thrusterIntensity = this.thrusterMode === 'cruise' ? 0.3 : 0.1;
                    if (this.spacecraft.children[2]) { // Port thruster
                        this.spacecraft.children[2].material.emissiveIntensity = thrusterIntensity + Math.sin(this.spacecraftHoverCycle * 3) * 0.1;
                    }
                    if (this.spacecraft.children[3]) { // Starboard thruster
                        this.spacecraft.children[3].material.emissiveIntensity = thrusterIntensity + Math.sin(this.spacecraftHoverCycle * 3) * 0.1;
                    }
                }
            }

            getTerrainHeight(x, z) {
                return this.generateHeight(x, z);
            }

            noise(x, y) {
                // Improved Perlin-style noise
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                
                const A = this.p[X] + Y;
                const AA = this.p[A];
                const AB = this.p[A + 1];
                const B = this.p[X + 1] + Y;
                const BA = this.p[B];
                const BB = this.p[B + 1];
                
                return this.lerp(v, 
                    this.lerp(u, this.grad(this.p[AA], x, y), this.grad(this.p[BA], x - 1, y)),
                    this.lerp(u, this.grad(this.p[AB], x, y - 1), this.grad(this.p[BB], x - 1, y - 1))
                );
            }

            // Perlin noise helper functions
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            // Permutation table for noise
            get p() {
                if (!this._p) {
                    this._p = [];
                    for (let i = 0; i < 256; i++) this._p[i] = i;
                    for (let i = 0; i < 256; i++) {
                        const j = Math.floor(Math.random() * 256);
                        [this._p[i], this._p[j]] = [this._p[j], this._p[i]];
                    }
                    this._p = this._p.concat(this._p);
                }
                return this._p;
            }

            generateInitialTerrain() {
                const centerX = Math.floor(this.playerPosition.x / this.chunkSize);
                const centerZ = Math.floor(this.playerPosition.z / this.chunkSize);
                
                for (let x = centerX - this.renderDistance; x <= centerX + this.renderDistance; x++) {
                    for (let z = centerZ - this.renderDistance; z <= centerZ + this.renderDistance; z++) {
                        this.loadChunk(x, z);
                    }
                }
            }

            loadChunk(x, z) {
                const key = `${x},${z}`;
                if (!this.chunks.has(key)) {
                    const chunk = this.generateTerrain(x, z);
                    this.chunks.set(key, chunk);
                    this.scene.add(chunk);
                }
            }

            unloadChunk(x, z) {
                const key = `${x},${z}`;
                if (this.chunks.has(key)) {
                    const chunk = this.chunks.get(key);
                    this.scene.remove(chunk);
                    this.chunks.delete(key);
                }
            }

            updateChunks() {
                const centerX = Math.floor(this.playerPosition.x / this.chunkSize);
                const centerZ = Math.floor(this.playerPosition.z / this.chunkSize);
                
                // Load new chunks
                for (let x = centerX - this.renderDistance; x <= centerX + this.renderDistance; x++) {
                    for (let z = centerZ - this.renderDistance; z <= centerZ + this.renderDistance; z++) {
                        this.loadChunk(x, z);
                    }
                }
                
                // Unload distant chunks
                for (let [key, chunk] of this.chunks) {
                    const [x, z] = key.split(',').map(Number);
                    if (Math.abs(x - centerX) > this.renderDistance || 
                        Math.abs(z - centerZ) > this.renderDistance) {
                        this.unloadChunk(x, z);
                    }
                }
            }

            setupEventListeners() {
                // Keyboard controls
                document.addEventListener('keydown', (event) => {
                    switch (event.code) {
                        case 'KeyW': this.controls.moveForward = true; break;
                        case 'KeyS': this.controls.moveBackward = true; break;
                        case 'KeyA': this.controls.moveLeft = true; break;
                        case 'KeyD': this.controls.moveRight = true; break;
                        case 'Space': this.controls.moveUp = true; event.preventDefault(); break;
                        case 'ShiftLeft': this.controls.moveDown = true; this.controls.sprint = true; break;
                        case 'KeyR': this.regenerateWorld(); break;
                        case 'KeyF': this.toggleWireframe(); break;
                        case 'KeyG': this.showWorldSelector(); break;
                        case 'KeyV': this.cycleViewMode(); break;
                        case 'KeyH': this.toggleMount(); break;
                    }
                });
                
                document.addEventListener('keyup', (event) => {
                    switch (event.code) {
                        case 'KeyW': this.controls.moveForward = false; break;
                        case 'KeyS': this.controls.moveBackward = false; break;
                        case 'KeyA': this.controls.moveLeft = false; break;
                        case 'KeyD': this.controls.moveRight = false; break;
                        case 'Space': this.controls.moveUp = false; break;
                        case 'ShiftLeft': this.controls.moveDown = false; this.controls.sprint = false; break;
                    }
                });
                
                // Mouse controls
                document.addEventListener('mousemove', (event) => {
                    if (document.pointerLockElement === document.body) {
                        this.mouseX += event.movementX * 0.002;
                        this.mouseY -= event.movementY * 0.002;
                        this.mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.mouseY));
                    }
                });
                
                // Pointer lock
                document.addEventListener('click', () => {
                    if (!document.getElementById('worldSelector').classList.contains('active')) {
                        document.body.requestPointerLock();
                    }
                });
                
                // Speed adjustment
                document.addEventListener('wheel', (event) => {
                    this.speed = Math.max(10, Math.min(this.maxSpeed, this.speed + event.deltaY * 0.1));
                });
                
                // Resize handling
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            showWorldSelector() {
                document.getElementById('worldSelector').classList.add('active');
                document.exitPointerLock();
            }

            hideWorldSelector() {
                document.getElementById('worldSelector').classList.remove('active');
            }

            generateSpecialWorld(type) {
                this.worldType = type;
                this.hideWorldSelector();
                this.regenerateWorld();
            }

            cycleViewMode() {
                this.viewMode = (this.viewMode + 1) % 3;
            }

            regenerateWorld() {
                // Clear existing chunks
                for (let [key, chunk] of this.chunks) {
                    this.scene.remove(chunk);
                }
                this.chunks.clear();
                
                // Generate new seed
                this.seed = Math.floor(Math.random() * 10000);
                this._p = null; // Reset noise permutation table
                
                // Update world seed display
                document.getElementById('worldSeed').textContent = this.seed.toString().padStart(4, '0');
                
                // Generate new terrain
                this.generateInitialTerrain();
                
                console.log(`🌍 New ${this.worldType} world generated! Seed: ${this.seed}`);
            }

            toggleWireframe() {
                this.wireframe = !this.wireframe;
                for (let [key, chunk] of this.chunks) {
                    if (chunk.material) {
                        chunk.material.wireframe = this.wireframe;
                    }
                }
            }

            updateMovement(delta) {
                // Initialize zero-gravity spacecraft systems if not already set
                if (!this.spacecraftThrusters) {
                    this.spacecraftThrusters = {
                        fuel: 100,
                        maxFuel: 100,
                        fuelConsumption: 15, // fuel per second when thrusting
                        thrustPower: 180,    // Acceleration in units/s²
                        rotationalThrust: 3.5, // Rotational acceleration
                        dampingFactor: 0.98  // Energy loss per frame (very minimal in space)
                    };
                    this.angularVelocity = new THREE.Vector3(0, 0, 0);
                }
                
                // Zero-gravity realistic physics - objects in motion stay in motion
                // Apply minimal dampening to simulate cosmic drag and micro-collisions
                this.velocity.multiplyScalar(this.spacecraftThrusters.dampingFactor);
                this.angularVelocity.multiplyScalar(this.spacecraftThrusters.dampingFactor);

                this.direction.z = Number(this.controls.moveForward) - Number(this.controls.moveBackward);
                this.direction.x = Number(this.controls.moveRight) - Number(this.controls.moveLeft);
                this.direction.y = Number(this.controls.moveUp) - Number(this.controls.moveDown);

                // Check if any thrusters are being used
                const thrusterActive = this.direction.length() > 0;
                
                if (thrusterActive && this.spacecraftThrusters.fuel > 0) {
                    // Normalize direction for consistent thrust force
                    this.direction.normalize();
                    
                    // Apply thrust force (Newton's laws - F = ma, so a = F/m)
                    const thrustForce = this.spacecraftThrusters.thrustPower * delta;
                    const boostMultiplier = this.controls.sprint ? 1.8 : 1.0;
                    
                    // Apply thrust in camera-relative directions for intuitive control
                    if (this.controls.moveForward || this.controls.moveBackward) {
                        this.velocity.z -= this.direction.z * thrustForce * boostMultiplier;
                    }
                    if (this.controls.moveLeft || this.controls.moveRight) {
                        this.velocity.x -= this.direction.x * thrustForce * boostMultiplier;
                    }
                    if (this.controls.moveUp || this.controls.moveDown) {
                        this.velocity.y += this.direction.y * thrustForce * boostMultiplier;
                    }
                    
                    // Consume fuel based on thrust intensity and boost usage
                    const fuelUsage = this.spacecraftThrusters.fuelConsumption * delta * boostMultiplier;
                    this.spacecraftThrusters.fuel = Math.max(0, this.spacecraftThrusters.fuel - fuelUsage);
                    
                    // Create thruster particle effects
                    this.createThrusterEffects(this.direction, boostMultiplier);
                } else {
                    // Regenerate fuel slowly when not thrusting (solar panels/reactor)
                    this.spacecraftThrusters.fuel = Math.min(
                        this.spacecraftThrusters.maxFuel,
                        this.spacecraftThrusters.fuel + 8 * delta
                    );
                }
                
                // Apply velocity limits to prevent unrealistic speeds
                const maxVelocity = 120; // Maximum velocity in any direction
                if (this.velocity.length() > maxVelocity) {
                    this.velocity.normalize().multiplyScalar(maxVelocity);
                }

                // Apply movement based on view mode
                if (this.viewMode === 0) {
                    // First person movement
                    const moveVector = new THREE.Vector3();
                    this.camera.getWorldDirection(moveVector);
                    moveVector.y = 0;
                    moveVector.normalize();
                    moveVector.multiplyScalar(-this.velocity.z * delta);

                    const sideVector = new THREE.Vector3();
                    sideVector.crossVectors(this.camera.up, moveVector).normalize();
                    sideVector.multiplyScalar(-this.velocity.x * delta);

                    this.playerPosition.add(moveVector);
                    this.playerPosition.add(sideVector);
                    this.playerPosition.y += this.velocity.y * delta;
                }

                // Detect walking for character animation
                this.isWalking = (this.controls.moveForward || this.controls.moveBackward || 
                                  this.controls.moveLeft || this.controls.moveRight) && !this.isMounted;

                // Keep player above ground with better terrain following
                const terrainHeight = this.getTerrainHeight(this.playerPosition.x, this.playerPosition.z);
                this.playerPosition.y = Math.max(terrainHeight + 5, this.playerPosition.y);

                // Update camera based on view mode
                this.updateCamera();
            }

            updateCamera() {
                switch (this.viewMode) {
                    case 0: // First person
                        this.camera.position.copy(this.playerPosition);
                        this.camera.rotation.y = this.mouseX;
                        this.camera.rotation.x = this.mouseY;
                        break;
                    
                    case 1: // Third person
                        const offset = new THREE.Vector3(0, 25, 40);
                        offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.mouseX);
                        this.camera.position.copy(this.playerPosition).add(offset);
                        this.camera.lookAt(this.playerPosition);
                        break;
                    
                    case 2: // Cinematic
                        const time = this.clock.getElapsedTime();
                        const cinematicOffset = new THREE.Vector3(
                            Math.sin(time * 0.3) * 50,
                            30 + Math.sin(time * 0.2) * 20,
                            Math.cos(time * 0.3) * 50
                        );
                        this.camera.position.copy(this.playerPosition).add(cinematicOffset);
                        this.camera.lookAt(this.playerPosition);
                        break;
                }
            }

            updateCosmicRadiation(delta) {
                if (!this.cosmicRadiationParticles) return;
                
                const positions = this.cosmicRadiationParticles.geometry.attributes.position.array;
                const colors = this.cosmicRadiationParticles.geometry.attributes.color.array;
                const time = this.clock.getElapsedTime();
                
                for (let i = 0; i < positions.length; i += 3) {
                    const particleIndex = i / 3;
                    
                    // Update particle positions with cosmic drift
                    positions[i] += this.cosmicRadiationVelocities[i] * delta * 20;
                    positions[i + 1] += this.cosmicRadiationVelocities[i + 1] * delta * 20;
                    positions[i + 2] += this.cosmicRadiationVelocities[i + 2] * delta * 20;
                    
                    // Create subtle pulsing effect for cosmic energy
                    const pulsePhase = time * 0.5 + particleIndex * 0.1;
                    const energyPulse = (Math.sin(pulsePhase) + 1) * 0.5;
                    
                    // Modulate color intensity based on energy pulse
                    const baseR = colors[i];
                    const baseG = colors[i + 1];
                    const baseB = colors[i + 2];
                    
                    colors[i] = baseR * (0.7 + energyPulse * 0.3);
                    colors[i + 1] = baseG * (0.7 + energyPulse * 0.3);
                    colors[i + 2] = baseB * (0.7 + energyPulse * 0.3);
                    
                    // Reset particles that drift too far from cosmic center
                    const distanceFromCenter = Math.sqrt(
                        positions[i] * positions[i] + 
                        positions[i + 1] * positions[i + 1] + 
                        positions[i + 2] * positions[i + 2]
                    );
                    
                    if (distanceFromCenter > 3000) {
                        // Respawn particle at edge of cosmic radiation field
                        const radius = 1500 + Math.random() * 500;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        
                        positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                        positions[i + 1] = radius * Math.cos(phi) + (Math.random() - 0.5) * 400;
                        positions[i + 2] = radius * Math.sin(phi) * Math.sin(theta);
                        
                        // Reset velocity
                        this.cosmicRadiationVelocities[i] = (Math.random() - 0.5) * 0.8;
                        this.cosmicRadiationVelocities[i + 1] = (Math.random() - 0.5) * 0.8;
                        this.cosmicRadiationVelocities[i + 2] = (Math.random() - 0.5) * 0.8;
                    }
                }
                
                this.cosmicRadiationParticles.geometry.attributes.position.needsUpdate = true;
                this.cosmicRadiationParticles.geometry.attributes.color.needsUpdate = true;
            }

            updateLighting() {
                const time = this.clock.getElapsedTime();
                
                // Animate sun position for authentic Texas hill country day/night cycle
                this.sunLight.position.x = Math.cos(time * 0.1) * 200;
                this.sunLight.position.z = Math.sin(time * 0.1) * 200;
                
                // Check for major lighting changes (dawn/dusk) for narrative triggers
                const lightIntensity = Math.max(0.2, (this.sunLight.position.y + 50) / 100);
                
                // Trigger weather change narratives at dawn and dusk
                if (Math.abs(lightIntensity - 0.5) < 0.02 && Math.random() < 0.01) {
                    this.displayNarrative('weather_change');
                    
                    // Play atmospheric wind sound during transitions
                    if (this.audioEnabled && Math.random() < 0.3) {
                        this.playAtmosphericWind();
                    }
                }
                
                // Update sky shader
                if (this.sky.material.uniforms) {
                    this.sky.material.uniforms.time.value = time * 1000;
                }
                
                // Animate atmospheric lights
                this.atmosphericLights.forEach((light, index) => {
                    light.intensity = 0.2 + Math.sin(time + index) * 0.1;
                });
            }

            updateUI() {
                // Position and stats
                document.getElementById('coordinates').textContent = 
                    `${Math.round(this.playerPosition.x)}, ${Math.round(this.playerPosition.y)}, ${Math.round(this.playerPosition.z)}`;
                
                document.getElementById('altitude').textContent = 
                    `${Math.round(this.playerPosition.y)}m`;
                
                const velocity = Math.sqrt(this.velocity.x ** 2 + this.velocity.z ** 2) * 3.6;
                document.getElementById('speed').textContent = 
                    `${Math.round(velocity)} km/h`;
                
                // Dynamic biome detection
                const biomeNoise = this.noise(this.playerPosition.x * 0.01, this.playerPosition.z * 0.01);
                let biome = 'Frontier Plains';
                
                switch (this.worldType) {
                    case 'desert':
                        biome = 'Sonoran Desert';
                        break;
                    case 'forest':
                        biome = 'East Texas Piney Woods';
                        break;
                    case 'canyon':
                        biome = 'Palo Duro Badlands';
                        break;
                    case 'coast':
                        biome = 'Gulf Coastal Plains';
                        break;
                    default:
                        if (biomeNoise > 0.3) biome = 'High Plains Desert';
                        else if (biomeNoise > 0) biome = 'Rolling Prairie';
                        else if (biomeNoise > -0.3) biome = 'Forest Territory';
                        else biome = 'River Lowlands';
                }
                
                document.getElementById('biome').textContent = biome;
                
                // Performance stats
                document.getElementById('fps').textContent = Math.round(this.fps);
                document.getElementById('chunkCount').textContent = this.chunks.size;
                document.getElementById('triangles').textContent = 
                    (this.chunks.size * 64 * 64 * 2).toLocaleString();
                
                // Update minimap
                this.updateMinimap();
            }

            updateMinimap() {
                const canvas = document.getElementById('minimapCanvas');
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#002244';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw chunks
                const centerX = Math.floor(this.playerPosition.x / this.chunkSize);
                const centerZ = Math.floor(this.playerPosition.z / this.chunkSize);
                const scale = 10;
                
                for (let [key, chunk] of this.chunks) {
                    const [x, z] = key.split(',').map(Number);
                    const screenX = (x - centerX) * scale + canvas.width / 2;
                    const screenZ = (z - centerZ) * scale + canvas.height / 2;
                    
                    ctx.fillStyle = '#00B2A9';
                    ctx.fillRect(screenX - scale/2, screenZ - scale/2, scale, scale);
                }
                
                // Draw player position
                ctx.fillStyle = '#BF5700';
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw direction indicator
                ctx.strokeStyle = '#BF5700';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, canvas.height / 2);
                ctx.lineTo(
                    canvas.width / 2 + Math.sin(this.mouseX) * 15,
                    canvas.height / 2 + Math.cos(this.mouseX) * 15
                );
                ctx.stroke();
            }

            updatePerformance() {
                this.frameCount++;
                const now = performance.now();
                
                if (now - this.lastFPSUpdate > 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFPSUpdate = now;
                }
            }

            createCosmicStarField() {
                // Create spectacular star field background
                const starGeometry = new THREE.BufferGeometry();
                const starCount = 3000;
                const positions = new Float32Array(starCount * 3);
                const colors = new Float32Array(starCount * 3);
                
                for (let i = 0; i < starCount * 3; i += 3) {
                    // Distribute stars in a vast cosmic sphere
                    const radius = 2000 + Math.random() * 2000;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i + 1] = radius * Math.cos(phi);
                    positions[i + 2] = radius * Math.sin(phi) * Math.sin(theta);
                    
                    // Create diverse stellar colors
                    const starType = Math.random();
                    if (starType < 0.2) {
                        // Blue supergiant
                        colors[i] = 0.3; colors[i + 1] = 0.7; colors[i + 2] = 1.0;
                    } else if (starType < 0.4) {
                        // White dwarf
                        colors[i] = 1.0; colors[i + 1] = 1.0; colors[i + 2] = 0.95;
                    } else if (starType < 0.6) {
                        // Red giant
                        colors[i] = 1.0; colors[i + 1] = 0.4; colors[i + 2] = 0.2;
                    } else if (starType < 0.8) {
                        // Yellow main sequence
                        colors[i] = 1.0; colors[i + 1] = 0.9; colors[i + 2] = 0.4;
                    } else {
                        // Purple nebula star
                        colors[i] = 0.9; colors[i + 1] = 0.4; colors[i + 2] = 1.0;
                    }
                }
                
                starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const starMaterial = new THREE.PointsMaterial({
                    size: 5,
                    transparent: true,
                    opacity: 0.9,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending
                });
                
                this.starField = new THREE.Points(starGeometry, starMaterial);
                this.scene.add(this.starField);
                
                console.log('✨ Created cosmic star field with 3000 stars');
            }

            createPulsatingPhenomena() {
                // Create spectacular pulsating cosmic objects
                this.pulsatingObjects = [];
                
                // Create pulsating quasars
                for (let i = 0; i < 8; i++) {
                    const quasarGeometry = new THREE.SphereGeometry(12, 16, 16);
                    const quasarMaterial = new THREE.MeshLambertMaterial({
                        color: this.colors.primary,
                        emissive: this.colors.primary,
                        emissiveIntensity: 0.8,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const quasar = new THREE.Mesh(quasarGeometry, quasarMaterial);
                    quasar.position.set(
                        (Math.random() - 0.5) * 2000,
                        Math.random() * 400 + 100,
                        (Math.random() - 0.5) * 2000
                    );
                    
                    // Add pulsing data for animation
                    quasar.userData.pulseSpeed = 0.5 + Math.random() * 2;
                    quasar.userData.pulsePhase = Math.random() * Math.PI * 2;
                    quasar.userData.baseIntensity = 0.8;
                    
                    this.scene.add(quasar);
                    this.pulsatingObjects.push(quasar);
                }
                
                // Create nebula clouds with dynamic colors
                for (let i = 0; i < 5; i++) {
                    const nebulaGeometry = new THREE.SphereGeometry(40, 12, 12);
                    const nebulaMaterial = new THREE.MeshLambertMaterial({
                        color: this.colors.secondary,
                        emissive: this.colors.accent,
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.4
                    });
                    
                    const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
                    nebula.position.set(
                        (Math.random() - 0.5) * 1500,
                        Math.random() * 300 + 200,
                        (Math.random() - 0.5) * 1500
                    );
                    
                    // Add slow pulsing for nebulae
                    nebula.userData.pulseSpeed = 0.2 + Math.random() * 0.5;
                    nebula.userData.pulsePhase = Math.random() * Math.PI * 2;
                    nebula.userData.baseIntensity = 0.3;
                    
                    this.scene.add(nebula);
                    this.pulsatingObjects.push(nebula);
                }
                
                console.log('🌌 Created pulsating cosmic phenomena');
            }

            createCosmicRadiationField() {
                // Create cosmic background radiation particle field with quantum fluctuations
                this.radiationField = new THREE.Group();
                
                // Cosmic microwave background particles
                const radiationGeometry = new THREE.BufferGeometry();
                const radiationCount = 2500;
                const positions = new Float32Array(radiationCount * 3);
                const colors = new Float32Array(radiationCount * 3);
                const velocities = new Float32Array(radiationCount * 3);
                const lifetimes = new Float32Array(radiationCount);
                
                // Quantum fluctuation color palette
                const quantumColors = [
                    new THREE.Color(0x4A90E2), // Quantum blue
                    new THREE.Color(0x9B59B6), // Cosmic violet
                    new THREE.Color(0x1ABC9C), // Teal energy
                    new THREE.Color(0xE74C3C), // Red-shifted
                    new THREE.Color(0xF39C12), // Amber radiation
                    new THREE.Color(0x2ECC71), // Green quantum field
                ];
                
                for (let i = 0; i < radiationCount; i++) {
                    // Distribute particles in spherical volume around player
                    const i3 = i * 3;
                    const radius = 150 + Math.random() * 300; // 150-450 units radius
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    
                    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = radius * Math.cos(phi) + (Math.random() - 0.5) * 100;
                    positions[i3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
                    
                    // Assign random quantum color
                    const color = quantumColors[Math.floor(Math.random() * quantumColors.length)];
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                    
                    // Random particle velocities for quantum fluctuation movement
                    velocities[i3] = (Math.random() - 0.5) * 0.5;
                    velocities[i3 + 1] = (Math.random() - 0.5) * 0.3;
                    velocities[i3 + 2] = (Math.random() - 0.5) * 0.5;
                    
                    // Lifetime for particle cycling (quantum decay/creation)
                    lifetimes[i] = Math.random() * 10000; // 0-10 second lifecycle
                }
                
                radiationGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                radiationGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                // Store custom attributes for animation
                radiationGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                radiationGeometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
                
                const radiationMaterial = new THREE.PointsMaterial({
                    size: 2.0,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.cosmicRadiation = new THREE.Points(radiationGeometry, radiationMaterial);
                this.radiationField.add(this.cosmicRadiation);
                
                // Add radiation field to scene
                this.scene.add(this.radiationField);
                
                // Store animation properties
                this.radiationCycle = 0;
                this.quantumFluctuationIntensity = 1.0;
                
                console.log('⚛️ Created cosmic background radiation field with quantum fluctuations');
            }

            createBlackHoles() {
                // Create gravitational black holes with event horizons and accretion disks
                this.blackHoles = [];
                
                const blackHoleCount = 3; // 3 black holes scattered across the cosmos
                
                for (let i = 0; i < blackHoleCount; i++) {
                    const blackHole = new THREE.Group();
                    
                    // Position black holes at strategic cosmic distances
                    const angle = (i / blackHoleCount) * Math.PI * 2 + (Math.random() - 0.5) * Math.PI;
                    const distance = 800 + Math.random() * 600; // 800-1400 units away
                    const elevation = (Math.random() - 0.5) * 400; // Varying heights
                    
                    blackHole.position.set(
                        Math.cos(angle) * distance,
                        elevation,
                        Math.sin(angle) * distance
                    );
                    
                    // Create the event horizon (perfectly black sphere)
                    const eventHorizonRadius = 20 + Math.random() * 15; // 20-35 unit radius
                    const eventHorizonGeometry = new THREE.SphereGeometry(eventHorizonRadius, 32, 32);
                    const eventHorizonMaterial = new THREE.MeshLambertMaterial({
                        color: 0x000000,
                        emissive: 0x000000,
                        emissiveIntensity: 0
                    });
                    const eventHorizon = new THREE.Mesh(eventHorizonGeometry, eventHorizonMaterial);
                    blackHole.add(eventHorizon);
                    
                    // Create the accretion disk (glowing swirling matter)
                    const diskGeometry = new THREE.RingGeometry(eventHorizonRadius * 2.5, eventHorizonRadius * 4, 32);
                    const diskMaterial = new THREE.MeshLambertMaterial({
                        color: this.colors.accent,
                        emissive: this.colors.accent,
                        emissiveIntensity: 0.4,
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.DoubleSide
                    });
                    const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
                    accretionDisk.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.3; // Slight tilt
                    blackHole.add(accretionDisk);
                    
                    // Create gravitational lensing ring effect
                    const lensingGeometry = new THREE.RingGeometry(eventHorizonRadius * 5, eventHorizonRadius * 5.5, 32);
                    const lensingMaterial = new THREE.MeshLambertMaterial({
                        color: this.colors.secondary,
                        emissive: this.colors.secondary,
                        emissiveIntensity: 0.2,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    });
                    const lensingRing = new THREE.Mesh(lensingGeometry, lensingMaterial);
                    lensingRing.rotation.x = Math.PI / 2;
                    blackHole.add(lensingRing);
                    
                    // Store black hole data for gravity calculations
                    blackHole.userData = {
                        mass: eventHorizonRadius * 1000, // Mass proportional to size
                        eventHorizonRadius: eventHorizonRadius,
                        influenceRadius: eventHorizonRadius * 15, // Gravity influence zone
                        rotationSpeed: 0.5 + Math.random() * 1.0 // Disk rotation speed
                    };
                    
                    this.scene.add(blackHole);
                    this.blackHoles.push(blackHole);
                }
                
                console.log(`🕳️ Created ${blackHoleCount} black holes with gravitational effects`);
            }

            createWormholePortals() {
                // Create traversable wormhole portals with space-time distortion effects
                this.wormholes = [];
                
                const wormholeCount = 2; // 2 wormhole portals for interstellar travel
                
                for (let i = 0; i < wormholeCount; i++) {
                    const wormhole = new THREE.Group();
                    
                    // Position wormholes at accessible cosmic locations
                    const angle = (i / wormholeCount) * Math.PI * 2 + Math.PI / 4;
                    const distance = 600 + Math.random() * 300; // 600-900 units away
                    const elevation = (Math.random() - 0.5) * 200;
                    
                    wormhole.position.set(
                        Math.cos(angle) * distance,
                        elevation,
                        Math.sin(angle) * distance
                    );
                    
                    // Create the wormhole throat (portal opening)
                    const throatRadius = 25 + Math.random() * 10; // 25-35 unit radius
                    const throatGeometry = new THREE.TorusGeometry(throatRadius, 3, 16, 32);
                    const throatMaterial = new THREE.MeshLambertMaterial({
                        color: this.colors.accent,
                        emissive: this.colors.accent,
                        emissiveIntensity: 0.8,
                        transparent: true,
                        opacity: 0.9
                    });
                    const throat = new THREE.Mesh(throatGeometry, throatMaterial);
                    wormhole.add(throat);
                    
                    // Create inner portal surface (space-time distortion)
                    const portalGeometry = new THREE.RingGeometry(5, throatRadius - 2, 32);
                    const portalMaterial = new THREE.MeshLambertMaterial({
                        color: this.colors.primary,
                        emissive: this.colors.primary,
                        emissiveIntensity: 0.6,
                        transparent: true,
                        opacity: 0.4,
                        side: THREE.DoubleSide
                    });
                    const portal = new THREE.Mesh(portalGeometry, portalMaterial);
                    portal.rotation.x = Math.PI / 2;
                    wormhole.add(portal);
                    
                    // Create exotic matter ring (Casimir energy visualization)
                    const exoticMatterGeometry = new THREE.TorusGeometry(throatRadius * 1.3, 1.5, 12, 24);
                    const exoticMatterMaterial = new THREE.MeshLambertMaterial({
                        color: this.colors.secondary,
                        emissive: this.colors.secondary,
                        emissiveIntensity: 1.2,
                        transparent: true,
                        opacity: 0.7
                    });
                    const exoticMatter = new THREE.Mesh(exoticMatterGeometry, exoticMatterMaterial);
                    exoticMatter.rotation.x = Math.PI / 6;
                    exoticMatter.rotation.z = Math.PI / 8;
                    wormhole.add(exoticMatter);
                    
                    // Create gravitational lensing effects (multiple rings)
                    for (let j = 0; j < 3; j++) {
                        const lensingRadius = throatRadius * (1.5 + j * 0.4);
                        const lensingGeometry = new THREE.RingGeometry(lensingRadius, lensingRadius + 2, 32);
                        const lensingMaterial = new THREE.MeshLambertMaterial({
                            color: 0x4A90E2,
                            emissive: 0x4A90E2,
                            emissiveIntensity: 0.3 - j * 0.08,
                            transparent: true,
                            opacity: 0.2 - j * 0.05,
                            side: THREE.DoubleSide
                        });
                        const lensingRing = new THREE.Mesh(lensingGeometry, lensingMaterial);
                        lensingRing.rotation.x = Math.PI / 2;
                        wormhole.add(lensingRing);
                    }
                    
                    // Create space-time particle vortex
                    const vortexGeometry = new THREE.BufferGeometry();
                    const vortexParticleCount = 150;
                    const vortexPositions = new Float32Array(vortexParticleCount * 3);
                    const vortexColors = new Float32Array(vortexParticleCount * 3);
                    
                    for (let j = 0; j < vortexParticleCount; j++) {
                        const j3 = j * 3;
                        const radius = Math.random() * throatRadius * 0.8;
                        const angle = Math.random() * Math.PI * 2;
                        const height = (Math.random() - 0.5) * 8;
                        
                        vortexPositions[j3] = Math.cos(angle) * radius;
                        vortexPositions[j3 + 1] = height;
                        vortexPositions[j3 + 2] = Math.sin(angle) * radius;
                        
                        // Gradient from cyan to purple
                        const intensity = Math.random();
                        vortexColors[j3] = 0.2 + intensity * 0.4;     // R
                        vortexColors[j3 + 1] = 0.6 + intensity * 0.3; // G
                        vortexColors[j3 + 2] = 0.8 + intensity * 0.2; // B
                    }
                    
                    vortexGeometry.setAttribute('position', new THREE.BufferAttribute(vortexPositions, 3));
                    vortexGeometry.setAttribute('color', new THREE.BufferAttribute(vortexColors, 3));
                    
                    const vortexMaterial = new THREE.PointsMaterial({
                        size: 2,
                        transparent: true,
                        opacity: 0.8,
                        vertexColors: true,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const vortexParticles = new THREE.Points(vortexGeometry, vortexMaterial);
                    wormhole.add(vortexParticles);
                    
                    // Store wormhole data for space-time effects
                    wormhole.userData = {
                        throatRadius: throatRadius,
                        rotationSpeed: 1.2 + Math.random() * 0.8,
                        portalEnergy: 100,
                        vortexParticles: vortexParticles,
                        destinationIndex: (i + 1) % wormholeCount // Link to next wormhole
                    };
                    
                    this.scene.add(wormhole);
                    this.wormholes.push(wormhole);
                }
                
                console.log(`🌀 Created ${wormholeCount} traversable wormhole portals with space-time effects`);
            }

            createAsteroidBelts() {
                // Create dynamic asteroid belt navigation systems
                this.asteroidBelts = [];
                this.asteroids = [];
                
                const beltCount = 3; // 3 asteroid belts at different orbital distances
                
                for (let beltIndex = 0; beltIndex < beltCount; beltIndex++) {
                    const belt = {
                        radius: 400 + beltIndex * 300, // 400, 700, 1000 unit radii
                        width: 100 + beltIndex * 50,   // Belt thickness
                        asteroidCount: 80 + beltIndex * 40, // 80, 120, 160 asteroids
                        orbitalSpeed: 0.3 - beltIndex * 0.08, // Slower outer belts
                        asteroids: []
                    };
                    
                    // Create asteroids for this belt
                    for (let i = 0; i < belt.asteroidCount; i++) {
                        const asteroid = new THREE.Group();
                        
                        // Random position within belt
                        const angle = (i / belt.asteroidCount) * Math.PI * 2 + Math.random() * 0.5;
                        const beltRadius = belt.radius + (Math.random() - 0.5) * belt.width;
                        const elevation = (Math.random() - 0.5) * 60; // Vertical spread
                        
                        asteroid.position.set(
                            Math.cos(angle) * beltRadius,
                            elevation,
                            Math.sin(angle) * beltRadius
                        );
                        
                        // Create irregular asteroid shape using multiple geometries
                        const asteroidSize = 3 + Math.random() * 8; // 3-11 unit radius
                        const asteroidType = Math.random();
                        
                        if (asteroidType < 0.4) {
                            // Rocky metallic asteroids
                            const geometry = new THREE.IcosahedronGeometry(asteroidSize, 1);
                            this.deformGeometry(geometry, asteroidSize * 0.3);
                            
                            const material = new THREE.MeshLambertMaterial({
                                color: new THREE.Color().setHSL(0.08 + Math.random() * 0.1, 0.6, 0.3),
                                emissive: new THREE.Color().setHSL(0.08, 0.3, 0.05),
                                emissiveIntensity: 0.1
                            });
                            
                            const mesh = new THREE.Mesh(geometry, material);
                            asteroid.add(mesh);
                        } else if (asteroidType < 0.7) {
                            // Ice asteroids with crystalline structure
                            const geometry = new THREE.DodecahedronGeometry(asteroidSize, 0);
                            this.deformGeometry(geometry, asteroidSize * 0.4);
                            
                            const material = new THREE.MeshLambertMaterial({
                                color: this.colors.secondary,
                                emissive: this.colors.secondary,
                                emissiveIntensity: 0.2,
                                transparent: true,
                                opacity: 0.8
                            });
                            
                            const mesh = new THREE.Mesh(geometry, material);
                            asteroid.add(mesh);
                        } else {
                            // Rare crystal asteroids with high energy emissions
                            const geometry = new THREE.OctahedronGeometry(asteroidSize, 1);
                            this.deformGeometry(geometry, asteroidSize * 0.2);
                            
                            const material = new THREE.MeshLambertMaterial({
                                color: this.colors.accent,
                                emissive: this.colors.accent,
                                emissiveIntensity: 0.6,
                                transparent: true,
                                opacity: 0.9
                            });
                            
                            const mesh = new THREE.Mesh(geometry, material);
                            asteroid.add(mesh);
                        }
                        
                        // Add surface details (craters, crystals)
                        if (Math.random() < 0.3) {
                            const detailCount = 1 + Math.floor(Math.random() * 3);
                            for (let j = 0; j < detailCount; j++) {
                                const detailGeometry = new THREE.SphereGeometry(asteroidSize * 0.15, 6, 4);
                                const detailMaterial = new THREE.MeshLambertMaterial({
                                    color: 0x2A2A2A,
                                    emissive: 0x1A1A1A,
                                    emissiveIntensity: 0.05
                                });
                                
                                const detail = new THREE.Mesh(detailGeometry, detailMaterial);
                                const detailAngle = Math.random() * Math.PI * 2;
                                const detailRadius = asteroidSize * 0.9;
                                detail.position.set(
                                    Math.cos(detailAngle) * detailRadius,
                                    (Math.random() - 0.5) * asteroidSize,
                                    Math.sin(detailAngle) * detailRadius
                                );
                                asteroid.add(detail);
                            }
                        }
                        
                        // Store asteroid navigation data
                        asteroid.userData = {
                            size: asteroidSize,
                            beltIndex: beltIndex,
                            orbitAngle: angle,
                            orbitRadius: beltRadius,
                            rotationSpeed: {
                                x: (Math.random() - 0.5) * 2,
                                y: (Math.random() - 0.5) * 2,
                                z: (Math.random() - 0.5) * 2
                            },
                            type: asteroidType < 0.4 ? 'rocky' : asteroidType < 0.7 ? 'ice' : 'crystal',
                            navigationHazard: asteroidSize > 6 // Large asteroids are navigation hazards
                        };
                        
                        this.scene.add(asteroid);
                        belt.asteroids.push(asteroid);
                        this.asteroids.push(asteroid);
                    }
                    
                    this.asteroidBelts.push(belt);
                }
                
                console.log(`☄️ Created ${beltCount} asteroid belts with ${this.asteroids.length} total asteroids`);
            }

            deformGeometry(geometry, deformAmount) {
                // Add realistic irregular deformation to asteroid geometry
                const positions = geometry.attributes.position.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    const vertex = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
                    const distance = vertex.length();
                    
                    // Apply noise-based deformation
                    const noise = (Math.random() - 0.5) * deformAmount;
                    const deformedDistance = distance + noise;
                    
                    vertex.normalize().multiplyScalar(deformedDistance);
                    
                    positions[i] = vertex.x;
                    positions[i + 1] = vertex.y;
                    positions[i + 2] = vertex.z;
                }
                
                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();
            }

            createFloatingParticles() {
                const particleContainer = document.getElementById('particles');
                
                for (let i = 0; i < 20; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.animationDelay = Math.random() * 20 + 's';
                    particle.style.animationDuration = (15 + Math.random() * 10) + 's';
                    particleContainer.appendChild(particle);
                }
            }

            hideLoadingScreen() {
                // This method is called from init(), but loading screen is now managed 
                // by the main window.addEventListener('load') handler
                // So we don't need to do anything here
                console.log('🎮 Game initialization complete - loading screen managed externally');
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                const delta = this.clock.getDelta();
                
                this.updateMovement(delta);
                this.updateChunks();
                this.updateCosmicRadiation(delta);
                this.updateLighting();
                this.updateUI();
                this.updatePerformance();
                this.animateCharacters(delta);
                this.checkLandmarkDiscovery();
                this.animatePulsatingPhenomena(delta);
                this.animateCosmicRadiation(delta);
                this.applyBlackHoleGravity(delta);
                this.animateWormholePortals(delta);
                this.animateAsteroidBelts(delta);
                this.updateThrusterParticles(delta);
                this.updateSpacecraftUI();
                
                this.renderer.render(this.scene, this.camera);
            }

            animatePulsatingPhenomena(delta) {
                if (!this.pulsatingObjects) return;
                
                const time = this.clock.getElapsedTime();
                
                this.pulsatingObjects.forEach(obj => {
                    if (obj.userData && obj.material) {
                        // Create pulsing effect on emissive intensity
                        const pulse = Math.sin(time * obj.userData.pulseSpeed + obj.userData.pulsePhase) * 0.5 + 0.5;
                        obj.material.emissiveIntensity = obj.userData.baseIntensity * (0.5 + pulse * 0.5);
                        
                        // Add subtle size pulsing for quasars
                        if (obj.geometry.type === 'SphereGeometry') {
                            const scalePulse = 1 + Math.sin(time * obj.userData.pulseSpeed * 2 + obj.userData.pulsePhase) * 0.1;
                            obj.scale.setScalar(scalePulse);
                        }
                    }
                });
                
                // Slowly rotate the star field for cosmic movement
                if (this.starField) {
                    this.starField.rotation.y += delta * 0.02;
                }
            }

            animateCosmicRadiation(delta) {
                if (!this.cosmicRadiation) return;
                
                this.radiationCycle += delta * 2;
                const time = this.clock.getElapsedTime();
                
                const positions = this.cosmicRadiation.geometry.attributes.position;
                const velocities = this.cosmicRadiation.geometry.attributes.velocity;
                const lifetimes = this.cosmicRadiation.geometry.attributes.lifetime;
                const colors = this.cosmicRadiation.geometry.attributes.color;
                
                // Quantum fluctuation color palette
                const quantumColors = [
                    new THREE.Color(0x4A90E2), // Quantum blue
                    new THREE.Color(0x9B59B6), // Cosmic violet
                    new THREE.Color(0x1ABC9C), // Teal energy
                    new THREE.Color(0xE74C3C), // Red-shifted
                    new THREE.Color(0xF39C12), // Amber radiation
                    new THREE.Color(0x2ECC71), // Green quantum field
                ];
                
                for (let i = 0; i < positions.count; i++) {
                    const i3 = i * 3;
                    
                    // Update particle positions based on quantum fluctuation
                    positions.array[i3] += velocities.array[i3] * delta * 10;
                    positions.array[i3 + 1] += velocities.array[i3 + 1] * delta * 10;
                    positions.array[i3 + 2] += velocities.array[i3 + 2] * delta * 10;
                    
                    // Apply quantum field oscillations
                    const quantum = Math.sin(time * 3 + i * 0.1) * 0.5;
                    positions.array[i3] += quantum * 0.1;
                    positions.array[i3 + 1] += Math.cos(time * 2 + i * 0.15) * 0.05;
                    positions.array[i3 + 2] += quantum * 0.08;
                    
                    // Update particle lifetime (quantum decay/creation cycle)
                    lifetimes.array[i] -= delta * 1000;
                    
                    // Regenerate particles that have reached end of lifecycle
                    if (lifetimes.array[i] <= 0) {
                        // Reset position in spherical distribution
                        const radius = 150 + Math.random() * 300;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos((Math.random() * 2) - 1);
                        
                        positions.array[i3] = radius * Math.sin(phi) * Math.cos(theta) + this.playerPosition.x;
                        positions.array[i3 + 1] = radius * Math.cos(phi) + this.playerPosition.y + (Math.random() - 0.5) * 100;
                        positions.array[i3 + 2] = radius * Math.sin(phi) * Math.sin(theta) + this.playerPosition.z;
                        
                        // New random velocity
                        velocities.array[i3] = (Math.random() - 0.5) * 0.5;
                        velocities.array[i3 + 1] = (Math.random() - 0.5) * 0.3;
                        velocities.array[i3 + 2] = (Math.random() - 0.5) * 0.5;
                        
                        // Reset lifetime
                        lifetimes.array[i] = Math.random() * 10000;
                        
                        // Change quantum color during regeneration
                        const newColor = quantumColors[Math.floor(Math.random() * quantumColors.length)];
                        colors.array[i3] = newColor.r;
                        colors.array[i3 + 1] = newColor.g;
                        colors.array[i3 + 2] = newColor.b;
                    }
                }
                
                // Mark attributes as needing update
                positions.needsUpdate = true;
                colors.needsUpdate = true;
                
                // Fluctuate overall opacity for cosmic breathing effect
                this.quantumFluctuationIntensity = 0.6 + Math.sin(time * 1.5) * 0.2;
                this.cosmicRadiation.material.opacity = this.quantumFluctuationIntensity;
                
                // Move radiation field center to follow player (maintain relative position)
                if (this.radiationField) {
                    const targetX = this.playerPosition.x * 0.1; // Slow parallax effect
                    const targetZ = this.playerPosition.z * 0.1;
                    this.radiationField.position.x += (targetX - this.radiationField.position.x) * delta * 0.5;
                    this.radiationField.position.z += (targetZ - this.radiationField.position.z) * delta * 0.5;
                }
            }

            applyBlackHoleGravity(delta) {
                if (!this.blackHoles || this.blackHoles.length === 0) return;
                
                // Apply gravitational effects to player character
                if (this.playerCharacter) {
                    const playerPosition = this.playerCharacter.position;
                    let totalGravityForce = new THREE.Vector3(0, 0, 0);
                    
                    this.blackHoles.forEach(blackHole => {
                        const blackHolePosition = blackHole.position;
                        const distance = playerPosition.distanceTo(blackHolePosition);
                        const influenceRadius = blackHole.userData.influenceRadius;
                        
                        // Only apply gravity if within influence radius
                        if (distance < influenceRadius && distance > blackHole.userData.eventHorizonRadius) {
                            // Calculate gravitational force using simplified physics
                            // F = G * M * m / r²  (but simplified for game physics)
                            const mass = blackHole.userData.mass;
                            const gravitationalConstant = 0.01; // Scaled for game physics
                            
                            const forceDirection = new THREE.Vector3()
                                .subVectors(blackHolePosition, playerPosition)
                                .normalize();
                            
                            const forceMagnitude = (gravitationalConstant * mass) / (distance * distance);
                            const gravityForce = forceDirection.multiplyScalar(forceMagnitude);
                            
                            totalGravityForce.add(gravityForce);
                            
                            // Create dramatic visual effects near black holes
                            if (distance < influenceRadius * 0.3) {
                                this.createGravitationalLensingEffect(blackHole, distance);
                            }
                        }
                    });
                    
                    // Apply the total gravitational force to player movement
                    if (totalGravityForce.length() > 0) {
                        // Scale force by delta time for smooth movement
                        totalGravityForce.multiplyScalar(delta * 60); // 60 FPS normalization
                        
                        // Apply force to player position
                        this.playerPosition.add(totalGravityForce);
                        this.playerCharacter.position.copy(this.playerPosition);
                        
                        // Ensure player doesn't go below terrain
                        const terrainHeight = this.getTerrainHeight(this.playerPosition.x, this.playerPosition.z);
                        if (this.playerPosition.y < terrainHeight) {
                            this.playerPosition.y = terrainHeight;
                            this.playerCharacter.position.y = this.playerPosition.y + 3;
                        }
                    }
                }
                
                // Animate black hole accretion disks
                this.blackHoles.forEach(blackHole => {
                    const accretionDisk = blackHole.children[1]; // Second child is the accretion disk
                    if (accretionDisk) {
                        accretionDisk.rotation.z += delta * blackHole.userData.rotationSpeed;
                    }
                    
                    const lensingRing = blackHole.children[2]; // Third child is the lensing ring
                    if (lensingRing) {
                        lensingRing.rotation.z -= delta * blackHole.userData.rotationSpeed * 0.3;
                    }
                });
            }

            createGravitationalLensingEffect(blackHole, distance) {
                // Create visual distortion effects near black holes
                const time = this.clock.getElapsedTime();
                const lensingRing = blackHole.children[2];
                
                if (lensingRing) {
                    // Intensify the lensing ring as player approaches
                    const proximityFactor = 1 - (distance / blackHole.userData.influenceRadius);
                    lensingRing.material.emissiveIntensity = 0.2 + proximityFactor * 0.6;
                    
                    // Add temporal distortion pulsing effect
                    const temporalPulse = Math.sin(time * 4) * 0.1 + 0.9;
                    lensingRing.scale.setScalar(temporalPulse);
                }
            }

            animateWormholePortals(delta) {
                // Find all wormhole portals in landmarks
                this.scene.traverse((object) => {
                    if (object.userData && object.userData.landmarkType === 'wormholePortal') {
                        this.animateIndividualWormhole(object, delta);
                    }
                });
            }
            
            animateIndividualWormhole(wormhole, delta) {
                const time = this.clock.getElapsedTime();
                
                // Find and animate the central ring (first child)
                const centralRing = wormhole.children[0];
                if (centralRing) {
                    centralRing.rotation.z += delta * 0.5;
                }
                
                // Find and animate the event horizon (second child)
                const eventHorizon = wormhole.children[1];
                if (eventHorizon) {
                    eventHorizon.rotation.z -= delta * 0.3;
                    
                    // Pulse the event horizon intensity
                    const pulse = Math.sin(time * 2) * 0.4 + 1.0;
                    eventHorizon.material.emissiveIntensity = 1.2 * pulse;
                }
                
                // Animate swirling particles if they exist
                const particleSystem = wormhole.children[2];
                if (particleSystem && particleSystem.userData && particleSystem.userData.particleSystem) {
                    const particles = particleSystem.userData.particleSystem;
                    const positions = particles.geometry.attributes.position.array;
                    const rotationSpeed = particleSystem.userData.rotationSpeed || 0.02;
                    
                    for (let i = 0; i < particleSystem.userData.particleCount; i++) {
                        const i3 = i * 3;
                        const x = positions[i3];
                        const z = positions[i3 + 2];
                        
                        // Create spiral rotation
                        const currentAngle = Math.atan2(z, x);
                        const currentRadius = Math.sqrt(x * x + z * z);
                        const newAngle = currentAngle + delta * rotationSpeed * (2 + currentRadius * 0.1);
                        
                        positions[i3] = Math.cos(newAngle) * currentRadius;
                        positions[i3 + 2] = Math.sin(newAngle) * currentRadius;
                        
                        // Add slight vertical oscillation
                        positions[i3 + 1] += Math.sin(time * 3 + i * 0.1) * delta * 0.5;
                    }
                    
                    particles.geometry.attributes.position.needsUpdate = true;
                    
                    // Rotate the entire particle system
                    particles.rotation.z += delta * rotationSpeed;
                }
                
                // Animate outer stabilizing rings (children 3-5)
                for (let i = 3; i < 6; i++) {
                    const ring = wormhole.children[i];
                    if (ring) {
                        ring.rotation.z += delta * 0.1 * (i - 2);
                        
                        // Add ripple scaling effect
                        const ripple = Math.sin(time * 2 + i) * 0.1 + 1.0;
                        ring.scale.setScalar(ripple);
                    }
                }
                
                // Animate energy pillars and beams (children 6+)
                for (let i = 6; i < wormhole.children.length; i++) {
                    const component = wormhole.children[i];
                    if (component && component.material && component.material.emissive) {
                        const energyPulse = Math.sin(time * 4 + i * 0.5) * 0.3 + 0.7;
                        if (component.material.emissiveIntensity !== undefined) {
                            const baseIntensity = component.material.userData?.baseIntensity || component.material.emissiveIntensity;
                            component.material.emissiveIntensity = baseIntensity * energyPulse;
                        }
                    }
                }
            }
            
            // AI-Driven Dynamic Universe Generation System
            createAIDrivenUniverse() {
                this.aiUniverse = {
                    galaxyDensityMap: new Map(),
                    starFormationRegions: [],
                    cosmicEvents: [],
                    intelligentPlacements: [],
                    evolutionRate: 0.001,
                    complexityLevel: 1
                };
                
                this.initializeGalaxyStructure();
                this.createDynamicStarFormation();
                this.setupCosmicEventSystem();
                this.enableAdaptiveGeneration();
            }
            
            initializeGalaxyStructure() {
                // Create procedural galaxy arms using AI-driven density mapping
                const armCount = 4 + Math.floor(Math.random() * 3); // 4-6 spiral arms
                
                for (let arm = 0; arm < armCount; arm++) {
                    const armAngle = (arm / armCount) * Math.PI * 2;
                    const armData = {
                        angle: armAngle,
                        density: 0.3 + Math.random() * 0.7,
                        starCount: Math.floor(200 + Math.random() * 800),
                        civilizationProbability: 0.02 + Math.random() * 0.05
                    };
                    
                    this.generateSpiralArm(armData);
                }
                
                // Create galactic core with supermassive phenomena
                this.generateGalacticCore();
            }
            
            generateSpiralArm(armData) {
                const starsGenerated = [];
                
                for (let i = 0; i < armData.starCount; i++) {
                    const radius = 50 + Math.random() * 400; // Galaxy radius
                    const spiralFactor = radius * 0.01; // Spiral tightness
                    const angle = armData.angle + spiralFactor + (Math.random() - 0.5) * 0.5;
                    
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const y = (Math.random() - 0.5) * 40; // Galactic disk height
                    
                    const starData = {
                        position: { x, y, z },
                        type: this.determineStarType(radius, armData.density),
                        age: Math.random() * 13.8, // Billion years
                        hasplanets: Math.random() < 0.7,
                        civilization: Math.random() < armData.civilizationProbability
                    };
                    
                    if (starData.hasplanets) {
                        this.generatePlanetarySystem(starData);
                    }
                    
                    if (starData.civilization) {
                        this.generateAlienCivilization(starData);
                    }
                    
                    starsGenerated.push(starData);
                }
                
                this.aiUniverse.galaxyDensityMap.set(`arm_${armData.angle}`, starsGenerated);
            }
            
            determineStarType(galacticRadius, armDensity) {
                const coreDistance = galacticRadius / 450; // Normalized distance from core
                const metalicity = Math.max(0, 1 - coreDistance * 0.7); // Higher metals near core
                
                const random = Math.random();
                if (random < 0.05) return { type: 'O', color: 0x9bb2ff, mass: 15 + Math.random() * 75 }; // Blue supergiant
                else if (random < 0.15) return { type: 'B', color: 0xaabfff, mass: 3 + Math.random() * 12 }; // Blue-white
                else if (random < 0.25) return { type: 'A', color: 0xcad7ff, mass: 1.4 + Math.random() * 1.6 }; // White
                else if (random < 0.45) return { type: 'F', color: 0xf8f7ff, mass: 1.04 + Math.random() * 0.36 }; // Yellow-white
                else if (random < 0.65) return { type: 'G', color: 0xfff4ea, mass: 0.8 + Math.random() * 0.4 }; // Yellow (Sun-like)
                else if (random < 0.85) return { type: 'K', color: 0xffeedd, mass: 0.45 + Math.random() * 0.35 }; // Orange
                else return { type: 'M', color: 0xffccaa, mass: 0.08 + Math.random() * 0.37 }; // Red dwarf
            }
            
            generatePlanetarySystem(starData) {
                const planetCount = Math.floor(Math.random() * 8) + 1; // 1-8 planets
                starData.planets = [];
                
                for (let p = 0; p < planetCount; p++) {
                    const planet = {
                        orbit: (p + 1) * (1 + Math.random() * 3), // AU from star
                        type: this.determinePlanetType(starData.type, (p + 1)),
                        habitability: 0,
                        moons: Math.floor(Math.random() * 5)
                    };
                    
                    // Calculate habitability based on star type and orbital distance
                    const habZoneInner = Math.sqrt(starData.type.mass / 1.1);
                    const habZoneOuter = Math.sqrt(starData.type.mass / 0.53);
                    
                    if (planet.orbit >= habZoneInner && planet.orbit <= habZoneOuter) {
                        planet.habitability = 0.3 + Math.random() * 0.7;
                        planet.atmosphere = Math.random() < 0.8;
                        planet.water = Math.random() < 0.6;
                        planet.life = planet.habitability > 0.5 && Math.random() < 0.1;
                    }
                    
                    starData.planets.push(planet);
                }
            }
            
            determinePlanetType(starType, orbitPosition) {
                const random = Math.random();
                const isInnerSystem = orbitPosition <= 3;
                
                if (isInnerSystem) {
                    if (random < 0.3) return 'rocky';
                    else if (random < 0.6) return 'desert';
                    else return 'volcanic';
                } else {
                    if (random < 0.4) return 'gasGiant';
                    else if (random < 0.7) return 'iceGiant';
                    else return 'frozen';
                }
            }
            
            generateAlienCivilization(starData) {
                starData.civilization = {
                    type: this.determineCivilizationType(),
                    level: Math.random() * 3, // Kardashev scale approximation
                    technology: {
                        spaceFlight: Math.random() < 0.6,
                        interstellar: Math.random() < 0.2,
                        megaStructures: Math.random() < 0.05
                    },
                    temperament: Math.random(), // 0=hostile, 1=friendly
                    contactAttempts: 0
                };
                
                if (starData.civilization.technology.megaStructures) {
                    this.generateMegaStructure(starData);
                }
            }
            
            determineCivilizationType() {
                const types = ['aquatic', 'terrestrial', 'silicon', 'energy', 'collective', 'synthetic'];
                return types[Math.floor(Math.random() * types.length)];
            }
            
            generateMegaStructure(starData) {
                const structures = ['dysonSphere', 'ringWorld', 'matrioshkaBrain', 'aldersonDisk'];
                const structure = structures[Math.floor(Math.random() * structures.length)];
                
                starData.megaStructure = {
                    type: structure,
                    completion: Math.random(),
                    energyOutput: starData.type.mass * 1e26 * Math.random(),
                    detectable: true
                };
            }
            
            generateGalacticCore() {
                // Create central supermassive black hole
                this.aiUniverse.galacticCore = {
                    blackHole: {
                        mass: 4.1e6, // Solar masses (like Sagittarius A*)
                        accretionDisk: true,
                        jets: true,
                        eventHorizon: 12e6 // km
                    },
                    starFormation: 0.9, // High star formation rate
                    civilizations: Math.floor(Math.random() * 50) + 10,
                    ancientTechnology: Math.random() < 0.8
                };
            }
            
            createDynamicStarFormation() {
                // Create regions where new stars are actively forming
                const formationRegions = Math.floor(Math.random() * 8) + 3; // 3-10 regions
                
                for (let i = 0; i < formationRegions; i++) {
                    const region = {
                        center: {
                            x: (Math.random() - 0.5) * 800,
                            y: (Math.random() - 0.5) * 80,
                            z: (Math.random() - 0.5) * 800
                        },
                        radius: 20 + Math.random() * 80,
                        intensity: Math.random(),
                        newStarsPerCycle: Math.floor(Math.random() * 5) + 1,
                        nebulaDensity: 0.3 + Math.random() * 0.7,
                        age: Math.random() * 10 // Million years
                    };
                    
                    this.aiUniverse.starFormationRegions.push(region);
                    this.createNebulaCloud(region);
                }
            }
            
            createNebulaCloud(region) {
                const group = new THREE.Group();
                
                // Central emission nebula
                const nebulaGeometry = new THREE.SphereGeometry(region.radius, 16, 16);
                const nebulaMaterial = new THREE.MeshLambertMaterial({
                    color: this.colors.secondary,
                    emissive: this.colors.accent,
                    emissiveIntensity: region.nebulaDensity * 0.5,
                    transparent: true,
                    opacity: 0.3
                });
                
                const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
                nebula.position.set(region.center.x, region.center.y, region.center.z);
                group.add(nebula);
                
                // Protostar formations within nebula
                const protostarCount = region.newStarsPerCycle * 3;
                for (let p = 0; p < protostarCount; p++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * region.radius * 0.8;
                    const height = (Math.random() - 0.5) * region.radius * 0.4;
                    
                    const protostarGeometry = new THREE.SphereGeometry(1 + Math.random() * 3, 8, 8);
                    const protostarMaterial = new THREE.MeshLambertMaterial({
                        color: this.colors.primary,
                        emissive: this.colors.primary,
                        emissiveIntensity: 0.8,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const protostar = new THREE.Mesh(protostarGeometry, protostarMaterial);
                    protostar.position.set(
                        region.center.x + Math.cos(angle) * distance,
                        region.center.y + height,
                        region.center.z + Math.sin(angle) * distance
                    );
                    
                    group.add(protostar);
                }
                
                this.scene.add(group);
                region.visualRepresentation = group;
            }
            
            setupCosmicEventSystem() {
                // Define possible cosmic events that can occur dynamically
                this.cosmicEventTypes = [
                    'supernova', 'gammaRayBurst', 'neutronStarCollision', 
                    'blackHoleFormation', 'darkMatterInteraction', 'quantumFluctuation',
                    'hyperspaceAnomaly', 'temporalDistortion', 'dimensionalRift'
                ];
                
                // Initialize cosmic event scheduler
                this.scheduleNextCosmicEvent();
            }
            
            scheduleNextCosmicEvent() {
                const nextEventTime = Math.random() * 300000 + 60000; // 1-5 minutes
                
                setTimeout(() => {
                    this.triggerCosmicEvent();
                    this.scheduleNextCosmicEvent(); // Schedule the next event
                }, nextEventTime);
            }
            
            triggerCosmicEvent() {
                const eventType = this.cosmicEventTypes[Math.floor(Math.random() * this.cosmicEventTypes.length)];
                const eventLocation = {
                    x: (Math.random() - 0.5) * 1000,
                    y: (Math.random() - 0.5) * 100,
                    z: (Math.random() - 0.5) * 1000
                };
                
                const event = {
                    type: eventType,
                    location: eventLocation,
                    intensity: Math.random(),
                    duration: 10000 + Math.random() * 30000, // 10-40 seconds
                    startTime: this.clock.getElapsedTime(),
                    visual: null
                };
                
                // Create visual representation of the event
                event.visual = this.createCosmicEventVisual(event);
                this.scene.add(event.visual);
                
                // Add to active events
                this.aiUniverse.cosmicEvents.push(event);
                
                // Trigger narrative
                this.displayCosmicEventNarrative(event);
            }
            
            createCosmicEventVisual(event) {
                const group = new THREE.Group();
                group.position.set(event.location.x, event.location.y, event.location.z);
                
                switch (event.type) {
                    case 'supernova':
                        return this.createSupernovaVisual(event, group);
                    case 'gammaRayBurst':
                        return this.createGammaRayBurstVisual(event, group);
                    case 'blackHoleFormation':
                        return this.createBlackHoleFormationVisual(event, group);
                    case 'dimensionalRift':
                        return this.createDimensionalRiftVisual(event, group);
                    default:
                        return this.createGenericCosmicEventVisual(event, group);
                }
            }
            
            createSupernovaVisual(event, group) {
                // Expanding shockwave
                const shockwaveGeometry = new THREE.SphereGeometry(5, 32, 32);
                const shockwaveMaterial = new THREE.MeshLambertMaterial({
                    color: this.colors.accent,
                    emissive: this.colors.accent,
                    emissiveIntensity: 1.5,
                    transparent: true,
                    opacity: 0.8
                });
                
                const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
                group.add(shockwave);
                
                // Store for animation
                group.userData.shockwave = shockwave;
                group.userData.maxRadius = 50 + event.intensity * 100;
                
                return group;
            }
            
            createGammaRayBurstVisual(event, group) {
                // Focused energy beam
                const beamGeometry = new THREE.CylinderGeometry(0.5, 2, 100, 8);
                const beamMaterial = new THREE.MeshLambertMaterial({
                    color: this.colors.primary,
                    emissive: this.colors.primary,
                    emissiveIntensity: 2.0,
                    transparent: true,
                    opacity: 0.9
                });
                
                const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                beam.rotation.x = Math.PI / 2;
                group.add(beam);
                
                return group;
            }
            
            createDimensionalRiftVisual(event, group) {
                // Tear in spacetime
                const riftGeometry = new THREE.PlaneGeometry(20, 40);
                const riftMaterial = new THREE.MeshLambertMaterial({
                    color: this.colors.dark,
                    emissive: this.colors.secondary,
                    emissiveIntensity: 1.0,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                
                const rift = new THREE.Mesh(riftGeometry, riftMaterial);
                rift.rotation.y = Math.random() * Math.PI * 2;
                group.add(rift);
                
                // Add crackling energy around edges
                for (let i = 0; i < 12; i++) {
                    const sparkGeometry = new THREE.SphereGeometry(0.5, 6, 6);
                    const sparkMaterial = new THREE.MeshLambertMaterial({
                        color: this.colors.accent,
                        emissive: this.colors.accent,
                        emissiveIntensity: 1.8
                    });
                    
                    const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                    const angle = (i / 12) * Math.PI * 2;
                    spark.position.set(
                        Math.cos(angle) * 10,
                        (Math.random() - 0.5) * 40,
                        Math.sin(angle) * 5
                    );
                    group.add(spark);
                }
                
                return group;
            }
            
            createGenericCosmicEventVisual(event, group) {
                const eventGeometry = new THREE.SphereGeometry(8 + event.intensity * 12, 16, 16);
                const eventMaterial = new THREE.MeshLambertMaterial({
                    color: this.colors.secondary,
                    emissive: this.colors.primary,
                    emissiveIntensity: 0.5 + event.intensity,
                    transparent: true,
                    opacity: 0.7
                });
                
                const eventSphere = new THREE.Mesh(eventGeometry, eventMaterial);
                group.add(eventSphere);
                
                return group;
            }
            
            displayCosmicEventNarrative(event) {
                const narratives = {
                    'supernova': "A massive star has reached the end of its life, exploding in brilliant fury!",
                    'gammaRayBurst': "A focused beam of gamma radiation cuts through the cosmos!",
                    'neutronStarCollision': "Two ultra-dense neutron stars spiral into collision!",
                    'blackHoleFormation': "Spacetime itself collapses as a new black hole forms!",
                    'darkMatterInteraction': "Invisible dark matter streams interact with visible matter!",
                    'quantumFluctuation': "The quantum vacuum fluctuates, creating energy from nothing!",
                    'hyperspaceAnomaly': "An anomaly in hyperspace distorts local reality!",
                    'temporalDistortion': "Time itself bends and warps in this region!",
                    'dimensionalRift': "A tear in the fabric of spacetime reveals other dimensions!"
                };
                
                const message = narratives[event.type] || "A mysterious cosmic phenomenon manifests nearby!";
                this.displayNarrative(message, 'cosmic_event');
            }
            
            enableAdaptiveGeneration() {
                // Monitor player behavior and adapt universe generation
                this.aiUniverse.playerBehavior = {
                    explorationPattern: 'random',
                    preferredRegions: [],
                    discoveryRate: 0,
                    interactionStyle: 'curious'
                };
                
                // Start adaptive evolution
                setInterval(() => {
                    this.evolveUniverse();
                }, 60000); // Every minute
            }
            
            evolveUniverse() {
                // Analyze player behavior
                this.analyzePlayerBehavior();
                
                // Evolve star formation regions
                this.evolveStarFormationRegions();
                
                // Update cosmic events based on player preferences
                this.adaptCosmicEvents();
                
                // Increase complexity over time
                this.aiUniverse.complexityLevel += this.aiUniverse.evolutionRate;
            }
            
            analyzePlayerBehavior() {
                // Track player's favorite areas
                const playerPos = this.camera.position;
                const currentRegion = `${Math.floor(playerPos.x/100)},${Math.floor(playerPos.z/100)}`;
                
                if (!this.aiUniverse.playerBehavior.preferredRegions[currentRegion]) {
                    this.aiUniverse.playerBehavior.preferredRegions[currentRegion] = 0;
                }
                this.aiUniverse.playerBehavior.preferredRegions[currentRegion]++;
            }
            
            evolveStarFormationRegions() {
                this.aiUniverse.starFormationRegions.forEach(region => {
                    // Age the region
                    region.age += 0.1;
                    
                    // Potentially create new stars
                    if (Math.random() < region.intensity * this.aiUniverse.evolutionRate) {
                        this.createNewStar(region);
                    }
                    
                    // Update visual representation
                    if (region.visualRepresentation && region.visualRepresentation.children[0]) {
                        const nebula = region.visualRepresentation.children[0];
                        const ageFactor = Math.max(0, 1 - region.age / 100);
                        nebula.material.emissiveIntensity = region.nebulaDensity * 0.5 * ageFactor;
                        nebula.material.opacity = 0.3 * ageFactor;
                    }
                });
            }
            
            createNewStar(region) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * region.radius;
                
                const newStar = {
                    position: {
                        x: region.center.x + Math.cos(angle) * distance,
                        y: region.center.y + (Math.random() - 0.5) * 10,
                        z: region.center.z + Math.sin(angle) * distance
                    },
                    type: this.determineStarType(distance, region.nebulaDensity),
                    age: 0,
                    hasplanets: Math.random() < 0.5,
                    civilization: Math.random() < 0.01
                };
                
                // Add visual representation
                this.createStarVisual(newStar, region.visualRepresentation);
            }
            
            createStarVisual(star, parent) {
                const starGeometry = new THREE.SphereGeometry(0.5 + Math.random() * 1.5, 8, 8);
                const starMaterial = new THREE.MeshLambertMaterial({
                    color: star.type.color,
                    emissive: star.type.color,
                    emissiveIntensity: 0.8
                });
                
                const starMesh = new THREE.Mesh(starGeometry, starMaterial);
                starMesh.position.set(star.position.x, star.position.y, star.position.z);
                
                if (parent) {
                    parent.add(starMesh);
                } else {
                    this.scene.add(starMesh);
                }
                
                star.visual = starMesh;
            }
            
            adaptCosmicEvents() {
                // Adjust cosmic event frequency based on player engagement
                const engagementLevel = Object.keys(this.aiUniverse.playerBehavior.preferredRegions).length / 10;
                
                // More engaged players get more spectacular events
                if (engagementLevel > 0.5) {
                    this.cosmicEventTypes = this.cosmicEventTypes.concat(['hypernova', 'quasarActivation', 'galacticCollision']);
                }
            }

            animateAsteroidBelts(delta) {
                if (!this.asteroidBelts || this.asteroidBelts.length === 0) return;
                
                const time = this.clock.getElapsedTime();
                
                this.asteroidBelts.forEach((belt, beltIndex) => {
                    belt.asteroids.forEach(asteroid => {
                        const userData = asteroid.userData;
                        
                        // Update orbital position
                        userData.orbitAngle += delta * belt.orbitalSpeed;
                        
                        const newX = Math.cos(userData.orbitAngle) * userData.orbitRadius;
                        const newZ = Math.sin(userData.orbitAngle) * userData.orbitRadius;
                        
                        asteroid.position.x = newX;
                        asteroid.position.z = newZ;
                        
                        // Apply individual asteroid rotation
                        asteroid.rotation.x += delta * userData.rotationSpeed.x;
                        asteroid.rotation.y += delta * userData.rotationSpeed.y;
                        asteroid.rotation.z += delta * userData.rotationSpeed.z;
                        
                        // Add subtle oscillation for realistic movement
                        asteroid.position.y += Math.sin(time * 0.5 + userData.orbitAngle) * delta * 2;
                        
                        // Enhanced visual effects for crystal asteroids
                        if (userData.type === 'crystal') {
                            const crystalMesh = asteroid.children[0];
                            if (crystalMesh && crystalMesh.material) {
                                const energyPulse = Math.sin(time * 2 + userData.orbitAngle) * 0.3 + 0.7;
                                crystalMesh.material.emissiveIntensity = 0.6 * energyPulse;
                            }
                        }
                        
                        // Navigation collision detection with player
                        if (this.playerCharacter) {
                            const distance = asteroid.position.distanceTo(this.playerCharacter.position);
                            const collisionRadius = userData.size + 10; // Safety margin
                            
                            if (distance < collisionRadius) {
                                this.handleAsteroidNavigation(asteroid, distance);
                            }
                        }
                    });
                });
                
                // Update navigation hazard warnings
                this.updateNavigationHazards();
            }

            handleAsteroidNavigation(asteroid, distance) {
                const userData = asteroid.userData;
                
                if (userData.navigationHazard && distance < userData.size + 5) {
                    // Close proximity to large asteroid - navigation warning
                    this.displayNavigationWarning(asteroid);
                    
                    // Apply slight deflection force to simulate gravitational interaction
                    const deflectionDirection = new THREE.Vector3()
                        .subVectors(this.playerCharacter.position, asteroid.position)
                        .normalize();
                    
                    const deflectionForce = deflectionDirection.multiplyScalar(0.5);
                    this.playerPosition.add(deflectionForce);
                    this.playerCharacter.position.copy(this.playerPosition);
                }
                
                // Mining opportunity for crystal asteroids
                if (userData.type === 'crystal' && distance < userData.size + 3) {
                    this.displayMiningOpportunity(asteroid);
                }
            }

            displayNavigationWarning(asteroid) {
                // Create navigation hazard warning
                if (!this.navigationWarningCooldown) {
                    const warningMessage = `⚠️ Navigation Hazard: Large ${asteroid.userData.type} asteroid detected`;
                    this.displayNarrative('navigation', warningMessage);
                    
                    this.navigationWarningCooldown = true;
                    setTimeout(() => {
                        this.navigationWarningCooldown = false;
                    }, 3000);
                }
            }

            displayMiningOpportunity(asteroid) {
                // Create mining opportunity notification
                if (!this.miningOpportunityCooldown) {
                    const miningMessage = `💎 Mining Opportunity: Rare crystal asteroid in proximity`;
                    this.displayNarrative('mining', miningMessage);
                    
                    this.miningOpportunityCooldown = true;
                    setTimeout(() => {
                        this.miningOpportunityCooldown = false;
                    }, 5000);
                }
            }

            updateNavigationHazards() {
                // Update UI with asteroid belt navigation status
                if (!this.playerCharacter) return;
                
                let nearestHazard = null;
                let nearestDistance = Infinity;
                
                this.asteroids.forEach(asteroid => {
                    if (asteroid.userData.navigationHazard) {
                        const distance = asteroid.position.distanceTo(this.playerCharacter.position);
                        if (distance < nearestDistance && distance < 100) {
                            nearestDistance = distance;
                            nearestHazard = asteroid;
                        }
                    }
                });
                
                // Update navigation display
                const navDisplay = document.getElementById('navigationStatus');
                if (navDisplay) {
                    if (nearestHazard) {
                        const hazardType = nearestHazard.userData.type.charAt(0).toUpperCase() + 
                                         nearestHazard.userData.type.slice(1);
                        navDisplay.textContent = `Navigation: ${hazardType} asteroid ${Math.floor(nearestDistance)}m`;
                        navDisplay.className = 'navigation-warning';
                    } else {
                        navDisplay.textContent = 'Navigation: Clear space';
                        navDisplay.className = 'navigation-clear';
                    }
                }
            }

            // Add navigation status to UI
            addNavigationStatusToUI() {
                const uiContainer = document.querySelector('.ui-container');
                if (uiContainer && !document.getElementById('navigationStatus')) {
                    const navPanel = document.createElement('div');
                    navPanel.className = 'ui-panel navigation-panel';
                    navPanel.innerHTML = `
                        <h3>Navigation</h3>
                        <div id="navigationStatus" class="navigation-clear">Initializing...</div>
                    `;
                    uiContainer.appendChild(navPanel);
                }
            }

            createThrusterEffects(direction, boostMultiplier) {
                // Create visual thruster particle effects for spacecraft propulsion
                if (!this.thrusterParticles) {
                    this.thrusterParticles = [];
                }
                
                // Determine thruster positions based on astronaut character
                if (!this.playerCharacter) return;
                
                const thrusterPositions = [];
                
                // Add boot thrusters (existing magnetic boots)
                if (direction.y > 0) { // Upward thrust
                    thrusterPositions.push(
                        { pos: new THREE.Vector3(-0.6, -1.9, 1.0), dir: new THREE.Vector3(0, -1, 0) },
                        { pos: new THREE.Vector3(0.6, -1.9, 1.0), dir: new THREE.Vector3(0, -1, 0) }
                    );
                }
                
                // Add backpack thrusters for forward/backward movement
                if (Math.abs(direction.z) > 0) {
                    const thrustDirection = direction.z > 0 ? 
                        new THREE.Vector3(0, 0, 1) : new THREE.Vector3(0, 0, -1);
                    thrusterPositions.push(
                        { pos: new THREE.Vector3(0, 2.2, -1.2), dir: thrustDirection }
                    );
                }
                
                // Add side thrusters for strafing
                if (Math.abs(direction.x) > 0) {
                    const thrustDirection = direction.x > 0 ? 
                        new THREE.Vector3(1, 0, 0) : new THREE.Vector3(-1, 0, 0);
                    thrusterPositions.push(
                        { pos: new THREE.Vector3(direction.x > 0 ? -1.4 : 1.4, 2.0, 0), dir: thrustDirection }
                    );
                }
                
                // Create thruster particles for each active thruster
                thrusterPositions.forEach(thruster => {
                    for (let i = 0; i < (boostMultiplier > 1.5 ? 8 : 5); i++) {
                        const particle = {
                            position: thruster.pos.clone().add(this.playerCharacter.position),
                            velocity: thruster.dir.clone().multiplyScalar(
                                (15 + Math.random() * 10) * boostMultiplier
                            ),
                            life: 0.8 + Math.random() * 0.4,
                            maxLife: 0.8 + Math.random() * 0.4,
                            size: 1.5 + Math.random() * 1.0,
                            color: boostMultiplier > 1.5 ? 
                                { r: 0.2, g: 0.8, b: 1.0 } :  // Bright blue for boost
                                { r: 1.0, g: 0.6, b: 0.2 }    // Orange for normal thrust
                        };
                        
                        // Add some randomness to particle direction
                        particle.velocity.add(new THREE.Vector3(
                            (Math.random() - 0.5) * 4,
                            (Math.random() - 0.5) * 4,
                            (Math.random() - 0.5) * 4
                        ));
                        
                        this.thrusterParticles.push(particle);
                    }
                });
                
                // Limit particle count for performance
                if (this.thrusterParticles.length > 200) {
                    this.thrusterParticles = this.thrusterParticles.slice(-200);
                }
            }

            updateThrusterParticles(delta) {
                // Update and render thruster particle effects
                if (!this.thrusterParticles || this.thrusterParticles.length === 0) return;
                
                for (let i = this.thrusterParticles.length - 1; i >= 0; i--) {
                    const particle = this.thrusterParticles[i];
                    
                    // Update particle physics
                    particle.position.add(particle.velocity.clone().multiplyScalar(delta));
                    particle.life -= delta;
                    
                    // Apply some drag to particles
                    particle.velocity.multiplyScalar(0.95);
                    
                    // Remove expired particles
                    if (particle.life <= 0) {
                        this.thrusterParticles.splice(i, 1);
                        continue;
                    }
                    
                    // Create visual particle representation (if needed for debugging)
                    // In production, these would be rendered via a particle system
                }
            }

            updateSpacecraftUI() {
                // Update spacecraft fuel and velocity indicators
                if (!this.spacecraftThrusters) return;
                
                const fuelBar = document.getElementById('spacecraftFuel');
                const velocityDisplay = document.getElementById('spacecraftVelocity');
                
                if (fuelBar) {
                    const fuelPercent = (this.spacecraftThrusters.fuel / this.spacecraftThrusters.maxFuel) * 100;
                    fuelBar.style.width = fuelPercent + '%';
                    fuelBar.className = fuelPercent < 20 ? 'fuel-critical' : 'fuel-normal';
                }
                
                if (velocityDisplay) {
                    const speed = this.velocity.length();
                    velocityDisplay.textContent = `${Math.floor(speed * 10) / 10} m/s`;
                }
            }

            addSpacecraftUIElements() {
                // Add spacecraft-specific UI elements
                const uiContainer = document.querySelector('.ui-container');
                if (uiContainer && !document.getElementById('spacecraftPanel')) {
                    const spacecraftPanel = document.createElement('div');
                    spacecraftPanel.id = 'spacecraftPanel';
                    spacecraftPanel.className = 'ui-panel spacecraft-panel';
                    spacecraftPanel.innerHTML = `
                        <h3>🚀 Spacecraft Systems</h3>
                        <div class="spacecraft-stat">
                            <span>Fuel:</span>
                            <div class="fuel-bar-container">
                                <div id="spacecraftFuel" class="fuel-bar fuel-normal"></div>
                            </div>
                        </div>
                        <div class="spacecraft-stat">
                            <span>Velocity:</span>
                            <span id="spacecraftVelocity" class="velocity-display">0.0 m/s</span>
                        </div>
                        <div class="spacecraft-stat">
                            <span>Thrust:</span>
                            <span class="thrust-controls">WASD + Space/Shift</span>
                        </div>
                    `;
                    uiContainer.appendChild(spacecraftPanel);
                }
            }
        }

        // Loading progress management
        function updateLoadingProgress(progress, text) {
            const progressBar = document.getElementById('progressBar');
            const loadingText = document.getElementById('loadingText');
            if (progressBar) progressBar.style.width = progress + '%';
            if (loadingText) loadingText.textContent = text;
        }

        // Initialize the ultimate game experience
        let game;
        window.addEventListener('load', () => {
            console.log('🔥 Initializing Blaze Worlds Ultimate...');
            updateLoadingProgress(10, 'Checking Three.js...');
            
            try {
                // Check if Three.js is loaded
                if (typeof THREE === 'undefined') {
                    throw new Error('Three.js is not loaded!');
                }
                
                console.log('✅ Three.js loaded, version:', THREE.REVISION);
                updateLoadingProgress(25, 'Three.js loaded successfully!');
                
                // Check if canvas exists
                const canvas = document.getElementById('gameCanvas');
                if (!canvas) {
                    throw new Error('Game canvas not found!');
                }
                
                console.log('✅ Canvas found:', canvas);
                updateLoadingProgress(40, 'Setting up WebGL renderer...');
                
                // Small delay to show progress
                setTimeout(() => {
                    updateLoadingProgress(60, 'Generating cosmic universe...');
                    
                    setTimeout(() => {
                        // Initialize game
                        game = new BlazeWorldsUltimate();
                        console.log('✅ Game initialized successfully!');
                        
                        // Make game globally accessible for world selector buttons
                        window.game = game;
                        
                        updateLoadingProgress(90, 'Starting cosmic exploration...');
                        
                        // Hide loading screen after successful initialization
                        setTimeout(() => {
                            updateLoadingProgress(100, 'Welcome to the cosmos!');
                            
                            setTimeout(() => {
                                const loadingScreen = document.getElementById('loadingScreen');
                                if (loadingScreen) {
                                    loadingScreen.style.opacity = '0';
                                    loadingScreen.style.transition = 'opacity 0.5s ease';
                                    setTimeout(() => {
                                        loadingScreen.style.display = 'none';
                                    }, 500);
                                }
                            }, 500);
                        }, 500);
                    }, 300);
                }, 500);
                
            } catch (error) {
                console.error('❌ Failed to initialize game:', error);
                updateLoadingProgress(0, 'Initialization failed!');
                
                // Show error message to user
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(255, 0, 0, 0.9);
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    font-family: monospace;
                    z-index: 10001;
                    text-align: center;
                    max-width: 500px;
                `;
                errorDiv.innerHTML = `
                    <h3>🚨 Game Initialization Failed</h3>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <p>This usually happens when:</p>
                    <ul style="text-align: left; margin: 10px 0;">
                        <li>Three.js failed to load from CDN</li>
                        <li>WebGL is not supported by your browser</li>
                        <li>Browser blocked 3D acceleration</li>
                    </ul>
                    <p>Please try refreshing or use a different browser.</p>
                    <div style="margin-top: 15px;">
                        <button onclick="location.reload()" style="background: white; color: red; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin: 5px;">
                            🔄 Reload Page
                        </button>
                        <button onclick="window.open('chrome://settings/content/webGL')" style="background: #333; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin: 5px;">
                            ⚙️ Check WebGL
                        </button>
                    </div>
                `;
                document.body.appendChild(errorDiv);
            }
        });
    </script>

</body></html>